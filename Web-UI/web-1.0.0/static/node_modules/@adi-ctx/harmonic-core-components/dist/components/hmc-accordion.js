import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';
import { d as defineCustomElement$2 } from './icon.js';

const accordionCss = ":host{display:block;width:100%;border-bottom:1px solid var(--hmc-color-layout-divider-default, var(--hmc-color-gray-300, #b7bbc3));font-family:var(--font-family-body, \"Inter\", sans-serif)}.arrow{margin-right:2px;transition:all 0.2s ease-out}.arrow.open{transform:rotate(90deg)}.header{position:relative;display:flex;align-items:center;box-sizing:border-box}#header-button{font-family:var(--font-family-body, \"Inter\", sans-serif);font-size:var(--font-size-default, 14px);line-height:20px;font-weight:700;color:var(--hmc-color-content-default, var(--hmc-color-gray-black, #101820));background-color:var(--hmc-color-layout-container, var(--hmc-color-gray-white, #fff));cursor:pointer;display:flex;border:none;align-items:center;padding-left:2px;width:100%;height:40px}#header-button.xs{height:32px;font-size:var(--font-size-small, 12px);line-height:16px}#header-button:focus-visible{outline-offset:0;outline:2px solid var(--hmc-color-interactive-focus, var(--hmc-color-system-highlight-default, var(--hmc-color-purple-500, #b16ee0)))}#header-button:hover{color:var(--hmc-color-content-default, var(--hmc-color-gray-black, #101820));background-color:var(--hmc-color-interactive-silent-hover, var(--hmc-color-gray-200, #d5d8dc))}.content{display:flex;align-items:center;max-height:0;overflow:hidden;transition:max-height 0.2s ease-in-out}.content-inner{width:100%;padding:0 16px}:host(.has-parent){border-bottom:none}:host(.has-parent) .content-inner{padding-right:0}";

//NB: Keep in sync with stylesheet
const COLLAPSING_DURATION = 200;
const HmcAccordion$1 = /*@__PURE__*/ proxyCustomElement(class HmcAccordion extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.accordionChange = createEvent(this, "accordionChange", 3);
    this.isOpen = false;
    this.size = 'md';
  }
  watchIsOpenHandler(newValue) {
    this.isOpen = newValue;
    this.handlePanelCollapsing();
  }
  // Expand the accordion if it is closed and the focus moves within.
  handleFocusIn(ev) {
    if (!this.isOpen && ev.target !== this.el) {
      this.togglePanel();
    }
  }
  componentDidLoad() {
    if (this.container && this.isOpen) {
      this.container.style.maxHeight = 'unset';
    }
  }
  togglePanel() {
    this.isOpen = !this.isOpen;
    this.accordionChange.emit({ open: this.isOpen });
  }
  handleSetContainerHeight(timeoutDuration, shouldPanelOpen, desiredHeight) {
    // We need to get the current height of content cause it could be different
    // from the initial, e.i. extra elements could be rendered after the panel is open.
    const content = this.el.querySelector('[slot="content"]');
    // For animation, first need to set absolute height and then set it to a relative or null.
    // It is allowing to change container height properly in case of changing content.
    this.container.style.maxHeight = content.scrollHeight + 'px';
    setTimeout(() => {
      // Additional check if User change panel state while it's collapsing.
      if (this.isOpen === shouldPanelOpen) {
        this.container.style.maxHeight = desiredHeight;
      }
    }, timeoutDuration);
  }
  handlePanelCollapsing() {
    if (this.container) {
      if (!this.isOpen) {
        this.handleSetContainerHeight(0, false, null);
      }
      else {
        this.handleSetContainerHeight(COLLAPSING_DURATION + 10, true, 'unset');
      }
    }
  }
  render() {
    const { isOpen, size } = this;
    const hasAccordionParent = this.el.parentElement.closest('hmc-accordion') !== null;
    const accordionClasses = {
      'expanded': isOpen,
      'has-parent': hasAccordionParent,
    };
    const arrowClasses = {
      arrow: true,
      open: isOpen,
    };
    const headerClasses = {
      header: true,
    };
    const contentInnerClasses = {
      'content-inner': true,
    };
    return (h(Host, { class: accordionClasses }, h("div", { class: headerClasses, role: "heading", "aria-level": 3 }, h("button", { id: "header-button", class: { [size]: true }, "aria-expanded": isOpen ? 'true' : 'false', "aria-controls": "content", onClick: () => this.togglePanel() }, h("hmc-icon", { class: arrowClasses, name: "chevron-right-xs" }), h("slot", { name: "header" }))), h("div", { id: "content", class: "content", role: "region", "aria-labelledby": "header-button", ref: ref => (this.container = ref) }, h("div", { class: contentInnerClasses }, h("slot", { name: "content" })))));
  }
  get el() { return this; }
  static get watchers() { return {
    "isOpen": ["watchIsOpenHandler"]
  }; }
  static get style() { return accordionCss; }
}, [1, "hmc-accordion", {
    "isOpen": [1028, "open"],
    "size": [1]
  }, [[0, "focusin", "handleFocusIn"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["hmc-accordion", "hmc-icon"];
  components.forEach(tagName => { switch (tagName) {
    case "hmc-accordion":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, HmcAccordion$1);
      }
      break;
    case "hmc-icon":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}

const HmcAccordion = HmcAccordion$1;
const defineCustomElement = defineCustomElement$1;

export { HmcAccordion, defineCustomElement };
