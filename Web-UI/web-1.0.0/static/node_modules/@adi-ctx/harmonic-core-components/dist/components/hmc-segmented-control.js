import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';

const segmentedControlCss = ":host{display:flex;width:max-content}:host(.full-width){width:100%}:host(.full-width) ::slotted(hmc-segmented-button){width:100%;justify-content:center}:host(.segmented-control){border:1px solid var(--hmc-color-layout-divider-default, var(--hmc-color-gray-300, #b7bbc3));border-radius:4px;display:flex;align-items:center;gap:2px}::slotted(.segmented-button){margin-top:-1px;margin-bottom:-1px}::slotted(.segmented-button.first-child){margin-left:-1px}::slotted(.segmented-button.last-child){margin-right:-1px}::slotted(.divider){width:1px;height:24px;align-self:center;background:var(--hmc-color-layout-divider-default, var(--hmc-color-gray-300, #b7bbc3))}::slotted(.divider.sm){height:16px}::slotted(.divider.hidden){background:transparent}::slotted(.divider.xs){height:12px}";

const childrenSelector = 'hmc-segmented-button';
const HmcSegmentedControl$1 = /*@__PURE__*/ proxyCustomElement(class HmcSegmentedControl extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.segmentChanged = createEvent(this, "segmentChanged", 7);
    this.size = 'md';
    this.value = undefined;
    this.isFullWidth = false;
  }
  get buttons() {
    const buttons = Array.from(this.el.querySelectorAll(childrenSelector));
    return buttons;
  }
  setButtonsAttributes() {
    this.buttons.forEach(button => {
      button.isPressed = button.value === this.value;
    });
  }
  setButtonsFullWidth() {
    this.buttons.forEach(button => {
      button.isFullWidth = this.isFullWidth;
    });
  }
  componentDidLoad() {
    this.setButtonsAttributes();
    this.setButtonsFullWidth();
    const hasSelection = this.buttons.find(button => button.isPressed);
    if (!hasSelection) {
      this.buttons[0].isPressed = true;
      this.value = this.buttons[0].value;
    }
    this.addDynamicContent();
    this.removeDivider(this.value);
  }
  componentDidUpdate() {
    this.setButtonsAttributes();
  }
  onIsFullWidthChange() {
    this.setButtonsFullWidth();
  }
  segmentItemClickedHandler(event) {
    const newValue = event.detail;
    if (newValue !== this.value) {
      this.addDivider(this.value);
      this.removeDivider(newValue);
      this.value = newValue;
      this.segmentChanged.emit({ value: newValue });
    }
  }
  onKeydown(ev) {
    const buttons = this.buttons.filter(button => !button.isDisabled);
    // Only move the focus if the current focus is in the segmented group
    if (ev.target && buttons.includes(ev.target)) {
      const index = buttons.findIndex(button => button === ev.target);
      let next;
      // If hitting arrow down or arrow right, move to the next button
      // If we're on the last button, move to the first button
      if (['ArrowDown', 'ArrowRight'].includes(ev.code)) {
        next = index === buttons.length - 1 ? buttons[0] : buttons[index + 1];
      }
      // If hitting arrow up or arrow left, move to the previous button
      // If we're on the first button, move to the last button
      if (['ArrowUp', 'ArrowLeft'].includes(ev.code)) {
        next = index === 0 ? buttons[buttons.length - 1] : buttons[index - 1];
      }
      if (next && buttons.includes(next)) {
        next.setFocus(ev);
      }
    }
  }
  createDividerElement() {
    const dynamicComponent = document.createElement('div');
    var classes = 'divider';
    if (this.buttons != null) {
      this.size = this.buttons[0].size;
    }
    classes = classes + ' ' + this.size;
    dynamicComponent.setAttribute('class', classes);
    return dynamicComponent;
  }
  addDynamicContent() {
    this.buttons.forEach((child, index) => {
      child.classList.add('segmented-button');
      if (index < this.buttons.length - 1) {
        if (index === 0) {
          child.classList.add('first-child');
        }
        child.after(this.createDividerElement());
      }
      else {
        child.classList.add('last-child');
      }
    });
  }
  removeDivider(buttonValue) {
    const buttonIndex = this.buttons.findIndex(button => button.value === buttonValue);
    //not last button
    if (buttonIndex < this.buttons.length - 1) {
      this.el.querySelectorAll('.divider')[buttonIndex].classList.add('hidden');
    }
    //not first button
    if (buttonIndex !== 0) {
      this.el
        .querySelectorAll('.divider')[buttonIndex - 1].classList.add('hidden');
    }
  }
  addDivider(buttonValue) {
    const buttonIndex = this.buttons.findIndex(button => button.value === buttonValue);
    //not last button
    if (buttonIndex < this.buttons.length - 1) {
      this.el
        .querySelectorAll('.divider')[buttonIndex].classList.remove('hidden');
    }
    //not first button
    if (buttonIndex !== 0) {
      this.el
        .querySelectorAll('.divider')[buttonIndex - 1].classList.remove('hidden');
    }
  }
  render() {
    const { isFullWidth } = this;
    const classList = {
      'segmented-control': true,
      'full-width': isFullWidth,
    };
    return (h(Host, { class: classList, role: "group" }, h("slot", null)));
  }
  get el() { return this; }
  static get watchers() { return {
    "isFullWidth": ["onIsFullWidthChange"]
  }; }
  static get style() { return segmentedControlCss; }
}, [1, "hmc-segmented-control", {
    "value": [1025],
    "isFullWidth": [1028, "full-width"]
  }, [[0, "segmentClicked", "segmentItemClickedHandler"], [0, "keydown", "onKeydown"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["hmc-segmented-control"];
  components.forEach(tagName => { switch (tagName) {
    case "hmc-segmented-control":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, HmcSegmentedControl$1);
      }
      break;
  } });
}

const HmcSegmentedControl = HmcSegmentedControl$1;
const defineCustomElement = defineCustomElement$1;

export { HmcSegmentedControl, defineCustomElement };
