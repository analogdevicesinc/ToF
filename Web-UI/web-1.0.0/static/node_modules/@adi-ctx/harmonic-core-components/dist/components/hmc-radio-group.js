import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';
import { r as renderHiddenInput } from './utils.js';

const HmcRadioGroup$1 = /*@__PURE__*/ proxyCustomElement(class HmcRadioGroup extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.radioChanged = createEvent(this, "radioChanged", 7);
    this.onClick = (ev) => {
      ev.preventDefault();
      const selectedRadio = ev.target && ev.target.closest('hmc-radio-button');
      if (selectedRadio) {
        const newValue = selectedRadio.value;
        if (newValue !== this.value) {
          this.value = newValue;
        }
      }
    };
    this.name = '';
    this.value = undefined;
  }
  valueChanged(value) {
    this.setActiveItem(value);
  }
  getRadios() {
    return Array.from(this.el.querySelectorAll('hmc-radio-button'));
  }
  onKeydown(ev) {
    if (ev.target && !this.el.contains(ev.target)) {
      return;
    }
    // Get all radios inside of the radio group and then
    // filter out disabled radios since we need to skip those
    const radios = this.getRadios().filter(radio => !radio.isDisabled);
    // Only move the radio if the current focus is in the radio group
    if (ev.target && radios.includes(ev.target)) {
      const index = radios.findIndex(radio => radio === ev.target);
      const current = radios[index];
      let next;
      // If hitting arrow down or arrow right, move to the next radio
      // If we're on the last radio, move to the first radio
      if (['ArrowDown', 'ArrowRight'].includes(ev.code)) {
        next = index === radios.length - 1 ? radios[0] : radios[index + 1];
      }
      // If hitting arrow up or arrow left, move to the previous radio
      // If we're on the first radio, move to the last radio
      if (['ArrowUp', 'ArrowLeft'].includes(ev.code)) {
        next = index === 0 ? radios[radios.length - 1] : radios[index - 1];
      }
      if (next && radios.includes(next)) {
        next.setFocus(ev);
        this.value = next.value;
      }
      // Update the radio group value when a user presses the
      // space bar on top of a selected radio
      if (['Space'].includes(ev.code)) {
        this.value = current.value;
        // Prevent browsers from jumping
        // to the bottom of the screen
        ev.preventDefault();
      }
    }
  }
  render() {
    renderHiddenInput(this.el, this.name, false, this.value);
    return (h(Host, { role: "radiogroup", onClick: this.onClick }, h("slot", null)));
  }
  setActiveItem(value) {
    this.radioChanged.emit(value);
    const radios = this.getRadios();
    // Get the first radio that is not disabled and the checked one
    const first = radios.find(radio => !radio.isDisabled);
    const checked = radios.find(radio => radio.value === value && !radio.isDisabled);
    if (!first && !checked) {
      return;
    }
    // If an enabled checked radio exists, set it to be the focusable radio
    // otherwise we default to focus the first radio
    const focusable = checked || first;
    for (const radio of radios) {
      const tabindex = radio === focusable ? 0 : -1;
      radio.setButtonTabindex(tabindex);
    }
  }
  get el() { return this; }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
}, [1, "hmc-radio-group", {
    "name": [1],
    "value": [1032]
  }, [[4, "keydown", "onKeydown"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["hmc-radio-group"];
  components.forEach(tagName => { switch (tagName) {
    case "hmc-radio-group":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, HmcRadioGroup$1);
      }
      break;
  } });
}

const HmcRadioGroup = HmcRadioGroup$1;
const defineCustomElement = defineCustomElement$1;

export { HmcRadioGroup, defineCustomElement };
