import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-9bcb3512.js';
import { r as renderHiddenInput } from './utils-c0344a71.js';

const HmcRadioGroup = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.radioChanged = createEvent(this, "radioChanged", 7);
    this.onClick = (ev) => {
      ev.preventDefault();
      const selectedRadio = ev.target && ev.target.closest('hmc-radio-button');
      if (selectedRadio) {
        const newValue = selectedRadio.value;
        if (newValue !== this.value) {
          this.value = newValue;
        }
      }
    };
    this.name = '';
    this.value = undefined;
  }
  valueChanged(value) {
    this.setActiveItem(value);
  }
  getRadios() {
    return Array.from(this.el.querySelectorAll('hmc-radio-button'));
  }
  onKeydown(ev) {
    if (ev.target && !this.el.contains(ev.target)) {
      return;
    }
    // Get all radios inside of the radio group and then
    // filter out disabled radios since we need to skip those
    const radios = this.getRadios().filter(radio => !radio.isDisabled);
    // Only move the radio if the current focus is in the radio group
    if (ev.target && radios.includes(ev.target)) {
      const index = radios.findIndex(radio => radio === ev.target);
      const current = radios[index];
      let next;
      // If hitting arrow down or arrow right, move to the next radio
      // If we're on the last radio, move to the first radio
      if (['ArrowDown', 'ArrowRight'].includes(ev.code)) {
        next = index === radios.length - 1 ? radios[0] : radios[index + 1];
      }
      // If hitting arrow up or arrow left, move to the previous radio
      // If we're on the first radio, move to the last radio
      if (['ArrowUp', 'ArrowLeft'].includes(ev.code)) {
        next = index === 0 ? radios[radios.length - 1] : radios[index - 1];
      }
      if (next && radios.includes(next)) {
        next.setFocus(ev);
        this.value = next.value;
      }
      // Update the radio group value when a user presses the
      // space bar on top of a selected radio
      if (['Space'].includes(ev.code)) {
        this.value = current.value;
        // Prevent browsers from jumping
        // to the bottom of the screen
        ev.preventDefault();
      }
    }
  }
  render() {
    renderHiddenInput(this.el, this.name, false, this.value);
    return (h(Host, { role: "radiogroup", onClick: this.onClick }, h("slot", null)));
  }
  setActiveItem(value) {
    this.radioChanged.emit(value);
    const radios = this.getRadios();
    // Get the first radio that is not disabled and the checked one
    const first = radios.find(radio => !radio.isDisabled);
    const checked = radios.find(radio => radio.value === value && !radio.isDisabled);
    if (!first && !checked) {
      return;
    }
    // If an enabled checked radio exists, set it to be the focusable radio
    // otherwise we default to focus the first radio
    const focusable = checked || first;
    for (const radio of radios) {
      const tabindex = radio === focusable ? 0 : -1;
      radio.setButtonTabindex(tabindex);
    }
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};

export { HmcRadioGroup as hmc_radio_group };
