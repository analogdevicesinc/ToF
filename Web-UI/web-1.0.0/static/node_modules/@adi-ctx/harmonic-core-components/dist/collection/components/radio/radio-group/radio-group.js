import { h, Host, } from '@stencil/core';
import { renderHiddenInput } from '../../../utils/utils';
/**
 * @slot - An unnamed slot is used to pass a hmc-radio-buttons to the component.
 */
export class HmcRadioGroup {
  constructor() {
    this.onClick = (ev) => {
      ev.preventDefault();
      const selectedRadio = ev.target && ev.target.closest('hmc-radio-button');
      if (selectedRadio) {
        const newValue = selectedRadio.value;
        if (newValue !== this.value) {
          this.value = newValue;
        }
      }
    };
    this.name = '';
    this.value = undefined;
  }
  valueChanged(value) {
    this.setActiveItem(value);
  }
  getRadios() {
    return Array.from(this.el.querySelectorAll('hmc-radio-button'));
  }
  onKeydown(ev) {
    if (ev.target && !this.el.contains(ev.target)) {
      return;
    }
    // Get all radios inside of the radio group and then
    // filter out disabled radios since we need to skip those
    const radios = this.getRadios().filter(radio => !radio.isDisabled);
    // Only move the radio if the current focus is in the radio group
    if (ev.target && radios.includes(ev.target)) {
      const index = radios.findIndex(radio => radio === ev.target);
      const current = radios[index];
      let next;
      // If hitting arrow down or arrow right, move to the next radio
      // If we're on the last radio, move to the first radio
      if (['ArrowDown', 'ArrowRight'].includes(ev.code)) {
        next = index === radios.length - 1 ? radios[0] : radios[index + 1];
      }
      // If hitting arrow up or arrow left, move to the previous radio
      // If we're on the first radio, move to the last radio
      if (['ArrowUp', 'ArrowLeft'].includes(ev.code)) {
        next = index === 0 ? radios[radios.length - 1] : radios[index - 1];
      }
      if (next && radios.includes(next)) {
        next.setFocus(ev);
        this.value = next.value;
      }
      // Update the radio group value when a user presses the
      // space bar on top of a selected radio
      if (['Space'].includes(ev.code)) {
        this.value = current.value;
        // Prevent browsers from jumping
        // to the bottom of the screen
        ev.preventDefault();
      }
    }
  }
  render() {
    renderHiddenInput(this.el, this.name, false, this.value);
    return (h(Host, { role: "radiogroup", onClick: this.onClick }, h("slot", null)));
  }
  setActiveItem(value) {
    this.radioChanged.emit(value);
    const radios = this.getRadios();
    // Get the first radio that is not disabled and the checked one
    const first = radios.find(radio => !radio.isDisabled);
    const checked = radios.find(radio => radio.value === value && !radio.isDisabled);
    if (!first && !checked) {
      return;
    }
    // If an enabled checked radio exists, set it to be the focusable radio
    // otherwise we default to focus the first radio
    const focusable = checked || first;
    for (const radio of radios) {
      const tabindex = radio === focusable ? 0 : -1;
      radio.setButtonTabindex(tabindex);
    }
  }
  static get is() { return "hmc-radio-group"; }
  static get encapsulation() { return "shadow"; }
  static get properties() {
    return {
      "name": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The name of the control, which is submitted with the form data."
        },
        "attribute": "name",
        "reflect": false,
        "defaultValue": "''"
      },
      "value": {
        "type": "any",
        "mutable": true,
        "complexType": {
          "original": "any | null",
          "resolved": "any",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "the value of the radio group."
        },
        "attribute": "value",
        "reflect": false
      }
    };
  }
  static get events() {
    return [{
        "method": "radioChanged",
        "name": "radioChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "'radioChanged' event emitted when user clicks on particular radio button\nand value of that radio is passed as a param."
        },
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "el"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "valueChanged"
      }];
  }
  static get listeners() {
    return [{
        "name": "keydown",
        "method": "onKeydown",
        "target": "document",
        "capture": false,
        "passive": false
      }];
  }
}
