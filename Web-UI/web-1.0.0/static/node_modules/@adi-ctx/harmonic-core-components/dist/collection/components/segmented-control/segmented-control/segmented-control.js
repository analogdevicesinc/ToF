import { Host, h, } from '@stencil/core';
const childrenSelector = 'hmc-segmented-button';
/**
 * @slot - An unnamed slot is used to pass a hmc-segmented-buttons to the component.
 */
export class HmcSegmentedControl {
  constructor() {
    this.size = 'md';
    this.value = undefined;
    this.isFullWidth = false;
  }
  get buttons() {
    const buttons = Array.from(this.el.querySelectorAll(childrenSelector));
    return buttons;
  }
  setButtonsAttributes() {
    this.buttons.forEach(button => {
      button.isPressed = button.value === this.value;
    });
  }
  setButtonsFullWidth() {
    this.buttons.forEach(button => {
      button.isFullWidth = this.isFullWidth;
    });
  }
  componentDidLoad() {
    this.setButtonsAttributes();
    this.setButtonsFullWidth();
    const hasSelection = this.buttons.find(button => button.isPressed);
    if (!hasSelection) {
      this.buttons[0].isPressed = true;
      this.value = this.buttons[0].value;
    }
    this.addDynamicContent();
    this.removeDivider(this.value);
  }
  componentDidUpdate() {
    this.setButtonsAttributes();
  }
  onIsFullWidthChange() {
    this.setButtonsFullWidth();
  }
  segmentItemClickedHandler(event) {
    const newValue = event.detail;
    if (newValue !== this.value) {
      this.addDivider(this.value);
      this.removeDivider(newValue);
      this.value = newValue;
      this.segmentChanged.emit({ value: newValue });
    }
  }
  onKeydown(ev) {
    const buttons = this.buttons.filter(button => !button.isDisabled);
    // Only move the focus if the current focus is in the segmented group
    if (ev.target && buttons.includes(ev.target)) {
      const index = buttons.findIndex(button => button === ev.target);
      let next;
      // If hitting arrow down or arrow right, move to the next button
      // If we're on the last button, move to the first button
      if (['ArrowDown', 'ArrowRight'].includes(ev.code)) {
        next = index === buttons.length - 1 ? buttons[0] : buttons[index + 1];
      }
      // If hitting arrow up or arrow left, move to the previous button
      // If we're on the first button, move to the last button
      if (['ArrowUp', 'ArrowLeft'].includes(ev.code)) {
        next = index === 0 ? buttons[buttons.length - 1] : buttons[index - 1];
      }
      if (next && buttons.includes(next)) {
        next.setFocus(ev);
      }
    }
  }
  createDividerElement() {
    const dynamicComponent = document.createElement('div');
    var classes = 'divider';
    if (this.buttons != null) {
      this.size = this.buttons[0].size;
    }
    classes = classes + ' ' + this.size;
    dynamicComponent.setAttribute('class', classes);
    return dynamicComponent;
  }
  addDynamicContent() {
    this.buttons.forEach((child, index) => {
      child.classList.add('segmented-button');
      if (index < this.buttons.length - 1) {
        if (index === 0) {
          child.classList.add('first-child');
        }
        child.after(this.createDividerElement());
      }
      else {
        child.classList.add('last-child');
      }
    });
  }
  removeDivider(buttonValue) {
    const buttonIndex = this.buttons.findIndex(button => button.value === buttonValue);
    //not last button
    if (buttonIndex < this.buttons.length - 1) {
      this.el.querySelectorAll('.divider')[buttonIndex].classList.add('hidden');
    }
    //not first button
    if (buttonIndex !== 0) {
      this.el
        .querySelectorAll('.divider')[buttonIndex - 1].classList.add('hidden');
    }
  }
  addDivider(buttonValue) {
    const buttonIndex = this.buttons.findIndex(button => button.value === buttonValue);
    //not last button
    if (buttonIndex < this.buttons.length - 1) {
      this.el
        .querySelectorAll('.divider')[buttonIndex].classList.remove('hidden');
    }
    //not first button
    if (buttonIndex !== 0) {
      this.el
        .querySelectorAll('.divider')[buttonIndex - 1].classList.remove('hidden');
    }
  }
  render() {
    const { isFullWidth } = this;
    const classList = {
      'segmented-control': true,
      'full-width': isFullWidth,
    };
    return (h(Host, { class: classList, role: "group" }, h("slot", null)));
  }
  static get is() { return "hmc-segmented-control"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["segmented-control.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["segmented-control.css"]
    };
  }
  static get properties() {
    return {
      "value": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string | null",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "the value of the SegmentedControl."
        },
        "attribute": "value",
        "reflect": false
      },
      "isFullWidth": {
        "type": "boolean",
        "mutable": true,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "full-width",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get events() {
    return [{
        "method": "segmentChanged",
        "name": "segmentChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Emitted when the value property has changed."
        },
        "complexType": {
          "original": "any",
          "resolved": "any",
          "references": {}
        }
      }];
  }
  static get elementRef() { return "el"; }
  static get watchers() {
    return [{
        "propName": "isFullWidth",
        "methodName": "onIsFullWidthChange"
      }];
  }
  static get listeners() {
    return [{
        "name": "segmentClicked",
        "method": "segmentItemClickedHandler",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "keydown",
        "method": "onKeydown",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
