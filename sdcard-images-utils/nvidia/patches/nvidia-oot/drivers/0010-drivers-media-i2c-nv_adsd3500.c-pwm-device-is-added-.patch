From 54ceef49b34f90aca601fd20eb5aa65b45c99969 Mon Sep 17 00:00:00 2001
From: Sivasubramaniyan Padmanaban <sivasubramaniyan.padmanaban@analog.com>
Date: Fri, 18 Apr 2025 15:29:51 +0530
Subject: [PATCH] drivers: media: i2c: nv_adsd3500.c: pwm device is added as an
 optional property

Signed-off-by: Sivasubramaniyan Padmanaban <sivasubramaniyan.padmanaban@analog.com>
---
 drivers/media/i2c/nv_adsd3500.c | 31 ++++++++++++++++++++++---------
 1 file changed, 22 insertions(+), 9 deletions(-)

diff --git a/drivers/media/i2c/nv_adsd3500.c b/drivers/media/i2c/nv_adsd3500.c
index b21c0468..1030b099 100644
--- a/drivers/media/i2c/nv_adsd3500.c
+++ b/drivers/media/i2c/nv_adsd3500.c
@@ -74,7 +74,7 @@ struct adsd3500 {
 	int				irq;
 	int                             signalnum;
 
-	struct v4l2_ctrl 		*ctrls[10];
+	struct v4l2_ctrl 		*ctrls[15];
 	struct pwm_device 		*pwm_fsync;
 	struct dentry 			*debugfs;
 	struct task_struct 		*task;
@@ -404,6 +404,11 @@ static int adsd3500_set_fsync_trigger(struct adsd3500 *adsd3500, s32 val)
 {
 	int ret;
 
+	if(adsd3500->pwm_fsync == NULL){
+		dev_err(adsd3500->dev, "Failed to get the pwm device\n");
+		return -ENODEV;
+	}
+
 	if(adsd3500->curr_sync_mode == PWM_TRIGGER){
 		dev_info(adsd3500->dev, "Entered: %s value = %d\n",__func__, val);
 		ret = regmap_write(adsd3500->regmap, ENABLE_FSYNC_TRIGGER, val);
@@ -817,7 +822,7 @@ static int adsd3500_start_streaming(struct adsd3500 *adsd3500)
 {
 	int ret;
 
-	if(adsd3500->curr_sync_mode == PWM_TRIGGER){
+	if(adsd3500->pwm_fsync != NULL && adsd3500->curr_sync_mode == PWM_TRIGGER){
 		ret = pwm_enable(adsd3500->pwm_fsync);
 		if (ret)
 			dev_err(adsd3500->dev, "Could not enable FSYNC PWM\n");
@@ -835,7 +840,7 @@ static int adsd3500_stop_streaming(struct adsd3500 *adsd3500)
 {
 	int ret;
 
-	if(adsd3500->curr_sync_mode == PWM_TRIGGER){
+	if(adsd3500->pwm_fsync != NULL && adsd3500->curr_sync_mode == PWM_TRIGGER){
 		pwm_disable(adsd3500->pwm_fsync);
 		return ret;
 	}
@@ -891,10 +896,12 @@ static int adsd3500_set_frame_rate(struct adsd3500 *priv, s64 val)
 
 	priv->framerate = val;
 
-	pwm_init_state(priv->pwm_fsync, &state);
-	state.period = DIV_ROUND_UP(1 * NSEC_PER_SEC, priv->framerate);
-	pwm_set_relative_duty_cycle(&state, 50, 100);
-	ret = pwm_apply_state(priv->pwm_fsync, &state);
+	if(priv->pwm_fsync != NULL){
+		pwm_init_state(priv->pwm_fsync, &state);
+		state.period = DIV_ROUND_UP(1 * NSEC_PER_SEC, priv->framerate);
+		pwm_set_relative_duty_cycle(&state, 50, 100);
+		ret = pwm_apply_state(priv->pwm_fsync, &state);
+	}
 
 	ret = regmap_write(priv->regmap, SET_FRAMERATE_CMD, val);
 	if (ret < 0)
@@ -956,6 +963,11 @@ static int adsd3500_sync_mode(struct adsd3500 *adsd3500, s32 val){
 	struct pwm_state state;
 	int ret;
 
+	if(adsd3500->pwm_fsync == NULL){
+		dev_err(dev, "Failed to get the pwm device\n");
+		return -ENODEV;
+	}
+
 	dev_info(dev, "Entered: %s Value: %d\n", __func__, val);
 	adsd3500->curr_sync_mode = val;
 
@@ -1111,8 +1123,9 @@ static struct camera_common_pdata *adsd3500_parse_dt(struct i2c_client *client,
 
 	adsd3500->pwm_fsync = devm_pwm_get(&client->dev, NULL);
 	if(IS_ERR(adsd3500->pwm_fsync)){
-		dev_err(&client->dev, "Failed to get the pwm device\n");
-		goto error;
+		dev_warn(&client->dev, "Failed to get the pwm device\n");
+		adsd3500->pwm_fsync = NULL;
+		return board_priv_pdata;
 	}
 
 	adsd3500->framerate = ADSD3500_DEFAULT_FPS;
-- 
2.25.1

