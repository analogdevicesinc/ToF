From 5bdb4f57458b859fd3901b96ca230d5cf9117387 Mon Sep 17 00:00:00 2001
From: Bogdan Togorean <bogdan.togorean@analog.com>
Date: Thu, 5 May 2022 11:36:40 +0300
Subject: [PATCH 33/36] Rename addicmos to adsd3100

Signed-off-by: Bogdan Togorean <bogdan.togorean@analog.com>
---
 .../dts/freescale/imx8mp-adi-tof-noreg.dts    |   31 +-
 drivers/media/spi/Kconfig                     |   10 +-
 drivers/media/spi/Makefile                    |    2 +-
 drivers/media/spi/addicmos.c                  | 1117 -----------------
 drivers/media/spi/adsd3100.c                  | 1117 +++++++++++++++++
 5 files changed, 1141 insertions(+), 1136 deletions(-)
 delete mode 100644 drivers/media/spi/addicmos.c
 create mode 100644 drivers/media/spi/adsd3100.c

diff --git a/arch/arm64/boot/dts/freescale/imx8mp-adi-tof-noreg.dts b/arch/arm64/boot/dts/freescale/imx8mp-adi-tof-noreg.dts
index 87d81263e6a1..e8a81ab5e80d 100644
--- a/arch/arm64/boot/dts/freescale/imx8mp-adi-tof-noreg.dts
+++ b/arch/arm64/boot/dts/freescale/imx8mp-adi-tof-noreg.dts
@@ -85,7 +85,8 @@
 		regulator-max-microvolt = <5000000>;
 		gpio = <&gpio4 30 GPIO_ACTIVE_HIGH>;
 		enable-active-high;
-		status = "disabled";
+		status = "okay";
+		regulator-always-on;
 	};
 
 	reg_vmain: regulator-vmain {
@@ -97,7 +98,7 @@
 		regulator-max-microvolt = <5000000>;
 		gpio = <&gpio5 0 GPIO_ACTIVE_HIGH>;
 		enable-active-high;
-		status = "disabled";
+		status = "okay";
 	};
 
 	reg_vsys: regulator-vsys {
@@ -111,7 +112,8 @@
 		gpio = <&gpio5 1 GPIO_ACTIVE_HIGH>;
 		startup-delay-us = <70000>;
 		enable-active-high;
-		status = "disabled";
+		status = "okay";
+		regulator-always-on;
 	};
 
 	reg_vaux: regulator-vaux {
@@ -125,7 +127,8 @@
 		gpio = <&gpio4 31 GPIO_ACTIVE_HIGH>;
 		startup-delay-us = <100000>;
 		enable-active-high;
-		status = "disabled";
+		status = "okay";
+		regulator-always-on;
 	};
 
 	reg_vcc_3p3: regulator-vcc-3p3 {
@@ -139,7 +142,7 @@
 		startup-delay-us = <7000>;
 		enable-active-high;
 		regulator-always-on;
-		status = "disabled";
+		status = "okay";
 	};
 
 	reg_can1_stby: regulator-can1-stby {
@@ -443,7 +446,7 @@
 	port@0 {
 		reg = <0>;
 		mipi_csi0_ep: endpoint {
-			remote-endpoint = <&addicmos_ep>;
+			remote-endpoint = <&adsd3100_ep>;
 			data-lanes = <4>;
 			csis-hs-settle = <32>;
 			csis-clk-settle = <0>;
@@ -458,21 +461,21 @@
 	cs-gpios = <&gpio5 13 GPIO_ACTIVE_LOW>, <&gpio3 9 GPIO_ACTIVE_LOW>;
 	status = "okay";
 
-	addicmos@0 {
-		compatible = "adi,addicmos";
+	adsd3100@0 {
+		compatible = "adi,adsd3100";
 		reg = <0x0>;
 		spi-cpol;
 		spi-cpha;
 		spi-max-frequency = <16000000>;
 		reset-gpios = <&gpio3 0 GPIO_ACTIVE_LOW>;
 		pinctrl-names = "spi", "gpio";
-		pinctrl-0 = <&pinctrl_addicmos_spi>;
-		pinctrl-1 = <&pinctrl_addicmos_gpio>;
+		pinctrl-0 = <&pinctrl_adsd3100_spi>;
+		pinctrl-1 = <&pinctrl_adsd3100_gpio>;
 		pwms = <&pwm 0 50000000>;
 		pwm-names = "fsync";
 
 		port {
-			addicmos_ep: endpoint {
+			adsd3100_ep: endpoint {
 				remote-endpoint = <&mipi_csi0_ep>;
 				data-lanes = <1 2 3 4>;
 				clock-lanes = <0>;
@@ -717,6 +720,8 @@
 	vmmc-supply = <&reg_sd1_vmmc>;
 	reset-gpio = <&gpio2 11 GPIO_ACTIVE_LOW>;
 	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
 	brcmf: brcmf@1 {
 		reg = <1>;
 		compatible = "brcm,bcm4329-fmac";
@@ -1115,13 +1120,13 @@
 		>;
 	};
 
-	pinctrl_addicmos_spi: addicmos-spi-grp {
+	pinctrl_adsd3100_spi: adsd3100-spi-grp {
 		fsl,pins = <
 			MX8MP_IOMUXC_ECSPI2_MOSI__ECSPI2_MOSI		0x82 /* MOSI: spi master-out-slave-in */
 		>;
 	};
 
-	pinctrl_addicmos_gpio: addicmos-gpio-grp {
+	pinctrl_adsd3100_gpio: adsd3100-gpio-grp {
 		fsl,pins = <
 			MX8MP_IOMUXC_ECSPI2_MOSI__GPIO5_IO11		0x100 /* MOSI pin as GPIO with pull-down */
 		>;
diff --git a/drivers/media/spi/Kconfig b/drivers/media/spi/Kconfig
index f54820bf92b4..95a8a6e18128 100644
--- a/drivers/media/spi/Kconfig
+++ b/drivers/media/spi/Kconfig
@@ -15,19 +15,19 @@ config VIDEO_GS1662
 	help
 	  Enable the GS1662 driver which serializes video streams.
 
-config VIDEO_ADDICMOS
-	tristate "Analog Devices ADDICMOS ToF front-end support"
+config VIDEO_ADSD3100
+	tristate "Analog Devices ADSD3100 ToF sensor support"
 	depends on SPI && VIDEO_V4L2
 	select MEDIA_CONTROLLER
 	select VIDEO_V4L2_SUBDEV_API
 	select V4L2_FWNODE
 	select REGMAP_SPI
 	help
-	  This is a Video4Linux2 driver for Analog Devices ADDICMOS
-	  Time of Flight front-end
+	  This is a Video4Linux2 driver for Analog Devices ADSD3100
+	  Time of Flight sensor
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called addicmos.
+	  module will be called adsd3100.
 
 
 endmenu
diff --git a/drivers/media/spi/Makefile b/drivers/media/spi/Makefile
index b705d2bfa814..56e4a9ffde6d 100644
--- a/drivers/media/spi/Makefile
+++ b/drivers/media/spi/Makefile
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0-only
-obj-$(CONFIG_VIDEO_ADDICMOS) += addicmos.o
+obj-$(CONFIG_VIDEO_ADSD3100) += adsd3100.o
 obj-$(CONFIG_VIDEO_GS1662) += gs1662.o
 obj-$(CONFIG_CXD2880_SPI_DRV) += cxd2880-spi.o
 
diff --git a/drivers/media/spi/addicmos.c b/drivers/media/spi/addicmos.c
deleted file mode 100644
index b22928807ec7..000000000000
--- a/drivers/media/spi/addicmos.c
+++ /dev/null
@@ -1,1117 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Driver for the Analog Devices ADDICMOS ToF camera sensor.
- *
- * Copyright (C) 2019-2020 Analog Devices, All Rights Reserved.
- *
- */
-
-#include <linux/gpio/consumer.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/pwm.h>
-#include <linux/firmware.h>
-#include <linux/spi/spi.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/pm_runtime.h>
-#include <linux/regmap.h>
-#include <media/v4l2-ctrls.h>
-#include <media/v4l2-fwnode.h>
-#include <media/v4l2-subdev.h>
-
-#define FW_FILE_NAME	"adi/addicmos-fw.bin"
-#define ADDI_MAGIC	"ADDICMOS"
-
-static bool fw_load = false;
-module_param(fw_load, bool, 0644);
-MODULE_PARM_DESC(fw_load, "Boolean enabling/disabling FW loading by driver");
-
-static bool calib_load = false;
-module_param(calib_load, bool, 0644);
-MODULE_PARM_DESC(calib_load, "Boolean enabling/disabling Calibration loading by driver");
-
-struct addicmos_mode_info {
-	u32 width;
-	u32 height;
-	u32 pixel_rate;
-	u32 link_freq_idx;
-};
-
-struct addicmos_mode_fw_block {
-	const struct reg_sequence *mode_regs;
-	ssize_t regs_count;
-};
-
-struct addicmos_fw_header {
-	unsigned char magic[8];
-	__le32 modes_nr;
-	__le32 data_size_bytes;
-	__le16 data[];
-} __packed;
-
-struct addicmos {
-	struct regmap *regmap;
-	struct device *dev;
-	struct v4l2_subdev sd;
-	struct media_pad pad;
-	struct v4l2_mbus_framefmt fmt;
-	struct v4l2_rect crop;
-
-	const struct addicmos_mode_info *current_mode;
-
-	struct v4l2_ctrl_handler ctrls;
-	struct v4l2_ctrl *pixel_rate;
-	struct v4l2_ctrl *link_freq;
-	/* custom controls */
-	struct v4l2_ctrl *operating_mode;
-	struct v4l2_ctrl *set_chip_config;
-
-	struct mutex lock;
-	bool streaming;
-
-	struct gpio_desc *rst_gpio;
-	struct pinctrl *pinctrl;
-	struct pinctrl_state *pins_spi, *pins_gpio;
-
-	struct pwm_device *pwm_fsync;
-
-	/* FW related data */
-	int fw_regs_count;
-	struct reg_sequence *fw_regs;
-	u8 curr_operating_mode;
-
-	const struct firmware *fw;
-};
-
-static inline struct addicmos *to_addicmos(struct v4l2_subdev *sd)
-{
-	return container_of(sd, struct addicmos, sd);
-}
-
-#define V4L2_CID_ADDICMOS_OPERATING_MODE  (V4L2_CID_USER_ADDICMOS_BASE + 0)
-#define V4L2_CID_ADDICMOS_CHIP_CONFIG (V4L2_CID_USER_ADDICMOS_BASE + 1)
-
-static const struct reg_sequence addicmos_powerup_setting[] = {
-	{ 0x0000, 0x1d29 },
-	{ 0x0002, 0x43d1 },
-	{ 0x0000, 0x1d25 },
-	{ 0x0002, 0x0000 },
-	{ 0x0000, 0x1c99 },
-	{ 0x0002, 0x0069 },
-	{ 0x0002, 0x0060 },
-	{ 0x0002, 0x0061 },
-	{ 0x0002, 0x0307 },
-	{ 0x0002, 0x0069 },
-	{ 0x0002, 0x0105 },
-	{ 0x0002, 0x0000 },
-	{ 0x0002, 0x0069 },
-	{ 0x0002, 0x0060 },
-	{ 0x0002, 0x0061 },
-	{ 0x0002, 0x0307 },
-	{ 0x0002, 0x0000 },
-	{ 0x0002, 0x0000 },
-	{ 0x0002, 0x0000 },
-	{ 0x0002, 0x0303 },
-	{ 0x0002, 0x0069 },
-	{ 0x0002, 0x0060 },
-	{ 0x0002, 0x0061 },
-	{ 0x0002, 0x0307 },
-	{ 0x0002, 0x0060 },
-	{ 0x0002, 0x0059 },
-	{ 0x0002, 0x0059 },
-	{ 0x0002, 0x0301 },
-	{ 0x0002, 0x0000 },
-	{ 0x0002, 0x006f },
-	{ 0x0002, 0x0105 },
-	{ 0x0002, 0x006e },
-	{ 0x0002, 0x0067 },
-	{ 0x0002, 0x0063 },
-	{ 0x0002, 0x0301 },
-	{ 0x0002, 0x0068 },
-	{ 0x0002, 0x006e },
-	{ 0x0002, 0x0205 },
-	{ 0x0002, 0x646b },
-	{ 0x0002, 0x0021 },
-	{ 0x0172, 0x0a0a },
-	{ 0x0132, 0x0047 },
-	{ 0x0126, 0x0020 },
-	{ 0x0132, 0x0088 },
-	{ 0x0126, 0x0001 },
-	{ 0x0132, 0x001d },
-	{ 0x0126, 0x0008 },
-	{ 0x0132, 0x008b },
-	{ 0x0126, 0x0010 },
-	{ 0x0132, 0x0075 },
-	{ 0x0126, 0x0040 },
-	{ 0x0246, 0xc1fa },
-	{ 0x0102, 0x019e },
-	{ 0x0104, 0x009a },
-	{ 0x012e, 0x060a },
-	{ 0x0130, 0x1f10 },
-	{ 0x0520, 0x1a00 },
-	{ 0x0522, 0x1627 },
-	{ 0x0524, 0x1321 },
-	{ 0x0526, 0x0a8a },
-};
-
-static const struct reg_sequence addicmos_powerdown_setting[] = {
-};
-
-static const struct reg_sequence addicmos_standby_setting[] = {
-};
-
-static const s64 link_freq_tbl[] = {
-	732000000,
-	732000000,
-	732000000,
-	732000000,
-	732000000,
-	732000000
-};
-
-/* Elements of the structure must be ordered ascending by width & height */
-static const struct addicmos_mode_info addicmos_mode_info_data[] = {
-	{
-		.width = 3840,
-		.height = 216,
-		.pixel_rate = 488000000,
-		.link_freq_idx = 0 /* an index in link_freq_tbl[] */
-	},
-	{
-		.width = 4096,
-		.height = 64,
-		.pixel_rate = 488000000,
-		.link_freq_idx = 1 /* an index in link_freq_tbl[] */
-	},
-	{
-		.width = 4096,
-		.height = 256,
-		.pixel_rate = 488000000,
-		.link_freq_idx = 2 /* an index in link_freq_tbl[] */
-	},
-	{
-		.width = 4096,
-		.height = 640,
-		.pixel_rate = 488000000,
-		.link_freq_idx = 3 /* an index in link_freq_tbl[] */
-	},
-	{
-		.width = 4096,
-		.height = 2304,
-		.pixel_rate = 488000000,
-		.link_freq_idx = 4 /* an index in link_freq_tbl[] */
-	},
-	{
-		.width = 4096,
-		.height = 2560,
-		.pixel_rate = 488000000,
-		.link_freq_idx = 5 /* an index in link_freq_tbl[] */
-	}
-};
-
-static int addicmos_regmap_write(void *context, const void *data, size_t count)
-{
-	struct device *dev = context;
-	struct spi_device *spi = to_spi_device(dev);
-
-	return spi_write(spi, data, count);
-}
-
-static int addicmos_regmap_read(void *context,
-				const void *reg, size_t reg_size,
-				void *val, size_t val_size)
-{
-	struct device *dev = context;
-	struct spi_device *spi = to_spi_device(dev);
-	u16 *rx_buf;
-
-	/* First response word should be ignored so allocate more & discard */
-	rx_buf = (u16*)kmalloc(val_size + sizeof(u16), GFP_KERNEL);
-	if (!rx_buf)
-		return -ENOMEM;
-
-	spi_write_then_read(spi, reg, reg_size, rx_buf, val_size + sizeof(u16));
-	memcpy(val, rx_buf + 1, val_size);
-
-	kfree(rx_buf);
-	return 0;
-}
-
-static bool addicmos_regmap_accessible_reg(struct device *dev, unsigned int reg)
-{
-	if (reg % 2)
-		return 0;
-
-	if ((reg >= 0x000) && (reg <= 0x294))
-		return 1;
-	else if ((reg >= 0x300) && (reg <= 0x83e))
-		return 1;
-	else if ((reg >= 0x900) && (reg <= 0xefe))
-		return 1;
-	else
-		return 0;
-}
-
-static struct regmap_bus addicmos_spi_bus_config = {
-	.write = addicmos_regmap_write,
-	.read = addicmos_regmap_read,
-	.read_flag_mask = 0x00,
-	.reg_format_endian_default = REGMAP_ENDIAN_BIG,
-	.val_format_endian_default = REGMAP_ENDIAN_BIG,
-};
-
-static const struct regmap_config addicmos_spi_regmap_config = {
-	.reg_bits = 16,
-	.val_bits = 16,
-	.max_register = 0xefe,
-	.read_flag_mask = 0x00,
-	.write_flag_mask = 0x80,
-	.cache_type = REGCACHE_NONE,
-	.readable_reg = addicmos_regmap_accessible_reg,
-};
-
-static int addicmos_power_on(struct device *dev)
-{
-	struct spi_device *client = to_spi_device(dev);
-	struct v4l2_subdev *sd = spi_get_drvdata(client);
-	struct addicmos *addicmos = to_addicmos(sd);
-	unsigned int read_val;
-	int i, ret;
-
-	dev_dbg(addicmos->dev, "Entered addicmos_power_on\n");
-
-	ret = regmap_write(addicmos->regmap, 0xC, 0xC5);
-	if (ret)
-		dev_err(addicmos->dev, "Could not set power up register\n");
-
-	for (i = 0; i < 10; i ++) {
-		msleep_interruptible(15);
-		regmap_read(addicmos->regmap, 0x256, &read_val);
-		if (read_val == 0x2) {
-			return 0;
-		}
-	}
-
-	dev_err(addicmos->dev, "Power on timed out.\n");
-	dev_dbg(addicmos->dev, "Status register 0x256 value: %x\n", read_val);
-	regmap_read(addicmos->regmap, 0x32, &read_val);
-	dev_dbg(addicmos->dev, "Status register 0x32 value: %x\n", read_val);
-
-	return -ETIME;
-}
-
-static int addicmos_power_off(struct device *dev)
-{
-	struct spi_device *client = to_spi_device(dev);
-	struct v4l2_subdev *sd = spi_get_drvdata(client);
-	struct addicmos *addicmos = to_addicmos(sd);
-	unsigned int read_val;
-	int i, ret;
-
-	if (!addicmos->streaming)
-		return 0;
-
-	dev_dbg(addicmos->dev, "Entered addicmos_power_off\n");
-
-	ret = regmap_write(addicmos->regmap, 0xC, 0x2);
-	if (ret)
-		dev_err(addicmos->dev, "Could not set power down register\n");
-
-	for (i = 0; i < 5; i ++) {
-		msleep_interruptible(100);
-		regmap_read(addicmos->regmap, 0xC, &read_val);
-		if (read_val == 0x0) {
-			return 0;
-		}
-	}
-
-	pwm_disable(addicmos->pwm_fsync);
-	dev_err(addicmos->dev, "Power off timed out.\n");
-	regmap_read(addicmos->regmap, 0x32, &read_val);
-	dev_dbg(addicmos->dev, "Status register 0x32 value: %x\n", read_val);
-
-	return -ETIME;
-}
-
-#ifdef CONFIG_VIDEO_ADV_DEBUG
-static int addicmos_g_register(struct v4l2_subdev *sd,
-			       struct v4l2_dbg_register *reg)
-{
-	struct addicmos *addicmos = to_addicmos(sd);
-	unsigned int read_val;
-	int ret;
-
-	reg->size = 2;
-	ret = regmap_read(addicmos->regmap, reg->reg, &read_val);
-	reg->val = read_val;
-
-	return ret;
-}
-
-static int addicmos_s_register(struct v4l2_subdev *sd,
-			       const struct v4l2_dbg_register *reg)
-{
-	struct addicmos *addicmos = to_addicmos(sd);
-
-	return regmap_write(addicmos->regmap, reg->reg, reg->val);
-}
-#endif
-
-static int addicmos_s_power(struct v4l2_subdev *sd, int on)
-{
-	struct addicmos *addicmos = to_addicmos(sd);
-
-	dev_dbg(addicmos->dev, "%s: %d\n", __func__, on);
-	return 0;
-}
-
-static int addicmos_chip_config(struct addicmos *addicmos,
-				    struct v4l2_ctrl *ctrl)
-{
-	uint16_t *val, *reg, val_nr, i;
-	bool burst;
-	int ret;
-
-	burst = *(ctrl->p_new.p_u16);
-	val_nr = *(ctrl->p_new.p_u16 + 1);
-	val = ctrl->p_new.p_u16 + 2;
-	reg = val + val_nr;
-
-	dev_dbg(addicmos->dev, "Entered addicmos_chip_config. ADDR: %x VAL_NR %d \n", *reg, val_nr);
-
-	if (*reg & 0x8000) { /* 0x8000 - write mask */
-		if (burst)
-			ret = regmap_bulk_write(addicmos->regmap, *reg, val, val_nr);
-		else
-			for (i=0; i<val_nr; i++)
-				ret = regmap_bulk_write(addicmos->regmap, *(reg + i), val + i, 1);
-		if (ret)
-			dev_warn(addicmos->dev,
-				"could not write to register %x\n", *reg);
-	} else {
-		if (burst)
-			ret = regmap_bulk_read(addicmos->regmap, *reg, val, val_nr);
-		else
-			for (i=0; i<val_nr; i++)
-				ret = regmap_bulk_read(addicmos->regmap, *(reg + i), val + i, 1);
-		if (ret)
-			dev_warn(addicmos->dev,
-				"could not read from register %x\n", *reg);
-	}
-
-	return 0;
-}
-
-static int addicmos_s_ctrl(struct v4l2_ctrl *ctrl)
-{
-	struct addicmos *addicmos = container_of(ctrl->handler,
-						 struct addicmos, ctrls);
-	int ret = 0;
-
-	switch (ctrl->id) {
-	case V4L2_CID_ADDICMOS_OPERATING_MODE:
-		addicmos->curr_operating_mode = ctrl->val;
-		break;
-	case V4L2_CID_ADDICMOS_CHIP_CONFIG:
-		ret = addicmos_chip_config(addicmos, ctrl);
-		break;
-	case V4L2_CID_PIXEL_RATE:
-	case V4L2_CID_LINK_FREQ:
-		break;
-	default:
-		dev_err(addicmos->dev, "%s > Unhandled: %x  param=%x\n",
-			__func__, ctrl->id, ctrl->val);
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-static const struct v4l2_ctrl_ops addicmos_ctrl_ops = {
-	.s_ctrl = addicmos_s_ctrl,
-};
-
-static const struct v4l2_ctrl_config addicmos_ctrl_chip_config = {
-	.ops		= &addicmos_ctrl_ops,
-	.id		= V4L2_CID_ADDICMOS_CHIP_CONFIG,
-	.name		= "Chip Config",
-	.type		= V4L2_CTRL_TYPE_U16,
-	.def		= 0xFF,
-	.min		= 0x00,
-	.max		= 0xFFFF,
-	.step		= 1,
-	.dims		= { 65537 },
-};
-
-static const struct v4l2_ctrl_config addicmos_ctrl_operating_mode = {
-	.ops		= &addicmos_ctrl_ops,
-	.id		= V4L2_CID_ADDICMOS_OPERATING_MODE,
-	.name		= "Operating Mode",
-	.type		= V4L2_CTRL_TYPE_INTEGER,
-	.def		= 0,
-	.min		= 0,
-	.max		= 10,
-	.step		= 1,
-};
-
-static int addicmos_enum_mbus_code(struct v4l2_subdev *sd,
-				   struct v4l2_subdev_pad_config *cfg,
-				   struct v4l2_subdev_mbus_code_enum *code)
-{
-	if (code->index > 0)
-		return -EINVAL;
-
-	code->code = MEDIA_BUS_FMT_SBGGR12_1X12;
-
-	return 0;
-}
-
-static int addicmos_enum_frame_size(struct v4l2_subdev *subdev,
-				    struct v4l2_subdev_pad_config *cfg,
-				    struct v4l2_subdev_frame_size_enum *fse)
-{
-	if (fse->code != MEDIA_BUS_FMT_SBGGR12_1X12)
-		return -EINVAL;
-
-	if (fse->index >= ARRAY_SIZE(addicmos_mode_info_data))
-		return -EINVAL;
-
-	fse->min_width = addicmos_mode_info_data[fse->index].width;
-	fse->max_width = addicmos_mode_info_data[fse->index].width;
-	fse->min_height = addicmos_mode_info_data[fse->index].height;
-	fse->max_height = addicmos_mode_info_data[fse->index].height;
-
-	return 0;
-}
-
-static struct v4l2_mbus_framefmt *
-addicmos_get_pad_format(struct addicmos *addicmos,
-			struct v4l2_subdev_pad_config *cfg, unsigned int pad,
-			enum v4l2_subdev_format_whence which)
-{
-	switch (which) {
-	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(&addicmos->sd, cfg, pad);
-	case V4L2_SUBDEV_FORMAT_ACTIVE:
-		return &addicmos->fmt;
-	default:
-		return ERR_PTR(-EINVAL);
-	}
-}
-
-static int addicmos_get_format(struct v4l2_subdev *sd,
-			       struct v4l2_subdev_pad_config *cfg,
-			       struct v4l2_subdev_format *format)
-{
-	struct addicmos *addicmos = to_addicmos(sd);
-	struct v4l2_mbus_framefmt *pad_format;
-
-	pad_format = addicmos_get_pad_format(addicmos, cfg, format->pad,
-					     format->which);
-	if (IS_ERR(pad_format))
-		return PTR_ERR(pad_format);
-
-	format->format = *pad_format;
-
-	return 0;
-}
-
-static struct v4l2_rect *
-addicmos_get_pad_crop(struct addicmos *addicmos,
-		      struct v4l2_subdev_pad_config *cfg,
-		      unsigned int pad, enum v4l2_subdev_format_whence which)
-{
-	switch (which) {
-	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_crop(&addicmos->sd, cfg, pad);
-	case V4L2_SUBDEV_FORMAT_ACTIVE:
-		return &addicmos->crop;
-	default:
-		return ERR_PTR(-EINVAL);
-	}
-}
-
-static int addicmos_set_format(struct v4l2_subdev *sd,
-			       struct v4l2_subdev_pad_config *cfg,
-			       struct v4l2_subdev_format *format)
-{
-	struct addicmos *addicmos = to_addicmos(sd);
-	struct v4l2_mbus_framefmt *framefmt;
-	struct v4l2_rect *crop;
-	const struct addicmos_mode_info *new_mode;
-	int ret;
-
-	dev_dbg(addicmos->dev, "set_fmt: %x %dx%d %d\n",
-		format->format.code, format->format.width,
-		format->format.height, format->which);
-
-	mutex_lock(&addicmos->lock);
-
-	crop = addicmos_get_pad_crop(addicmos, cfg, format->pad,
-				     format->which);
-	if (IS_ERR(crop))
-		return PTR_ERR(crop);
-
-	new_mode = v4l2_find_nearest_size(addicmos_mode_info_data,
-					  ARRAY_SIZE(addicmos_mode_info_data),
-					  width, height, format->format.width,
-					  format->format.height);
-	crop->width = new_mode->width;
-	crop->height = new_mode->height;
-
-	if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
-		ret = v4l2_ctrl_s_ctrl_int64(addicmos->pixel_rate,
-					     new_mode->pixel_rate);
-		if (ret < 0)
-			return ret;
-
-		ret = v4l2_ctrl_s_ctrl(addicmos->link_freq,
-				       new_mode->link_freq_idx);
-		if (ret < 0)
-			return ret;
-
-		addicmos->current_mode = new_mode;
-	}
-
-	framefmt = addicmos_get_pad_format(addicmos, cfg, format->pad,
-					   format->which);
-	if (IS_ERR(framefmt))
-		return PTR_ERR(framefmt);
-
-	framefmt->width = crop->width;
-	framefmt->height = crop->height;
-	framefmt->code = MEDIA_BUS_FMT_SBGGR12_1X12;
-	framefmt->field = V4L2_FIELD_NONE;
-	framefmt->colorspace = V4L2_COLORSPACE_RAW;
-
-	format->format = *framefmt;
-
-	mutex_unlock(&addicmos->lock);
-
-	return 0;
-}
-
-static int addicmos_entity_init_cfg(struct v4l2_subdev *subdev,
-				    struct v4l2_subdev_pad_config *cfg)
-{
-	struct v4l2_subdev_format fmt = { 0 };
-
-	fmt.which = cfg ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
-	fmt.format.width = addicmos_mode_info_data[0].width;
-	fmt.format.height = addicmos_mode_info_data[0].height;
-
-	addicmos_set_format(subdev, cfg, &fmt);
-
-	return 0;
-}
-
-static int addicmos_get_selection(struct v4l2_subdev *sd,
-				  struct v4l2_subdev_pad_config *cfg,
-				  struct v4l2_subdev_selection *sel)
-{
-	struct addicmos *addicmos = to_addicmos(sd);
-	struct v4l2_rect *crop;
-
-	if (sel->target != V4L2_SEL_TGT_CROP)
-		return -EINVAL;
-
-	crop = addicmos_get_pad_crop(addicmos, cfg, sel->pad, sel->which);
-	if (IS_ERR(crop))
-		return PTR_ERR(crop);
-
-	sel->r = *crop;
-
-	return 0;
-}
-
-static int addicmos_start_streaming(struct addicmos *addicmos)
-{
-	unsigned int read_val;
-	int ret;
-
-	regmap_read(addicmos->regmap, 0x210, &read_val);
-	if (read_val != addicmos->curr_operating_mode) {
-		ret = regmap_write(addicmos->regmap, 0x200,
-				   addicmos->curr_operating_mode);
-		if (ret)
-			dev_err(addicmos->dev, "Could not set mode register\n");
-		/* Reduce line width only for mode 1 */
-		if (addicmos->curr_operating_mode == 1)
-			ret = regmap_write(addicmos->regmap, 0x27e,0x8006);
-		else
-			ret = regmap_write(addicmos->regmap, 0x27e,0x0);
-	}
-
-	ret = pwm_enable(addicmos->pwm_fsync);
-	if (ret)
-		dev_err(addicmos->dev, "Could not enable FSYNC PWM\n");
-
-	addicmos->streaming = true;
-
-	return ret;
-}
-
-static int addicmos_stop_streaming(struct addicmos *addicmos)
-{
-	pwm_disable(addicmos->pwm_fsync);
-	addicmos->streaming = false;
-
-	return 0;
-}
-
-static int addicmos_s_stream(struct v4l2_subdev *subdev, int enable)
-{
-	struct addicmos *addicmos = to_addicmos(subdev);
-	int ret = 0;
-
-	dev_dbg(addicmos->dev, "s_stream: %d\n", enable);
-
-	mutex_lock(&addicmos->lock);
-	if (addicmos->streaming == enable) {
-		mutex_unlock(&addicmos->lock);
-		return 0;
-	}
-
-	if (enable) {
-		ret = pm_runtime_get_sync(addicmos->dev);
-		if (ret < 0) {
-			pm_runtime_put_noidle(addicmos->dev);
-			goto err_unlock;
-		}
-
-		ret = addicmos_start_streaming(addicmos);
-		if (ret)
-			goto err_rpm_put;
-	} else {
-		addicmos_stop_streaming(addicmos);
-		pm_runtime_put(addicmos->dev);
-	}
-
-	mutex_unlock(&addicmos->lock);
-
-	return ret;
-
-err_rpm_put:
-	pm_runtime_put(addicmos->dev);
-err_unlock:
-	mutex_unlock(&addicmos->lock);
-
-	return ret;
-}
-
-static int addicmos_g_frame_interval(struct v4l2_subdev *subdev,
-				     struct v4l2_subdev_frame_interval *fi)
-{
-	struct addicmos *addicmos = to_addicmos(subdev);
-	struct pwm_state state;
-
-	/* Sync up PWM state. */
-	pwm_init_state(addicmos->pwm_fsync, &state);
-
-	fi->interval.numerator = 1;
-	fi->interval.denominator =
-		(u32)(NSEC_PER_SEC / pwm_get_period(addicmos->pwm_fsync));
-	dev_dbg(addicmos->dev, "%s frame rate = %u / %u\n", __func__,
-		fi->interval.numerator, fi->interval.denominator);
-
-	return 0;
-}
-
-static int addicmos_s_frame_interval(struct v4l2_subdev *subdev,
-				     struct v4l2_subdev_frame_interval *fi)
-{
-	struct addicmos *addicmos = to_addicmos(subdev);
-	struct pwm_state state;
-	int ret = 0;
-
-	mutex_lock(&addicmos->lock);
-
-	/* Get PWM state. */
-	pwm_init_state(addicmos->pwm_fsync, &state);
-	state.period = DIV_ROUND_UP(fi->interval.numerator * NSEC_PER_SEC,
-				    fi->interval.denominator);
-	pwm_set_relative_duty_cycle(&state, 50, 100);
-	ret = pwm_apply_state(addicmos->pwm_fsync, &state);
-
-	dev_dbg(addicmos->dev, "Set frame interval to %u / %u\n",
-		fi->interval.numerator, fi->interval.denominator);
-
-	mutex_unlock(&addicmos->lock);
-
-	return ret;
-}
-
-static int addicmos_link_setup(struct media_entity *entity,
-			   const struct media_pad *local,
-			   const struct media_pad *remote, u32 flags)
-{
-	return 0;
-}
-
-static const struct v4l2_subdev_core_ops addicmos_core_ops = {
-#ifdef CONFIG_VIDEO_ADV_DEBUG
-	.g_register	= addicmos_g_register,
-	.s_register	= addicmos_s_register,
-#endif
-	.s_power = addicmos_s_power,
-};
-
-static const struct dev_pm_ops addicmos_pm_ops = {
-	SET_RUNTIME_PM_OPS(addicmos_power_off, addicmos_power_on, NULL)
-};
-
-static const struct v4l2_subdev_video_ops addicmos_video_ops = {
-	.s_stream		= addicmos_s_stream,
-	.g_frame_interval	= addicmos_g_frame_interval,
-	.s_frame_interval	= addicmos_s_frame_interval,
-};
-
-static const struct v4l2_subdev_pad_ops addicmos_subdev_pad_ops = {
-	.init_cfg		= addicmos_entity_init_cfg,
-	.enum_mbus_code		= addicmos_enum_mbus_code,
-	.enum_frame_size	= addicmos_enum_frame_size,
-	.get_fmt		= addicmos_get_format,
-	.set_fmt		= addicmos_set_format,
-	.get_selection		= addicmos_get_selection,
-};
-
-static const struct v4l2_subdev_ops addicmos_subdev_ops = {
-#ifdef CONFIG_VIDEO_ADV_DEBUG
-	.core	= &addicmos_core_ops,
-#endif
-	.video	= &addicmos_video_ops,
-	.pad	= &addicmos_subdev_pad_ops,
-};
-
-static const struct media_entity_operations addicmos_subdev_entity_ops = {
-	.link_setup = addicmos_link_setup,
-};
-
-static int addicmos_spi_bus_init(struct v4l2_subdev *sd)
-{
-	struct addicmos *addicmos = to_addicmos(sd);
-	unsigned int read_val;
-	int ret;
-
-	/* Set SPI pins to GPIO mode */
-	ret = pinctrl_select_state(addicmos->pinctrl, addicmos->pins_gpio);
-	if (ret < 0)
-		return ret;
-
-	gpiod_set_value_cansleep(addicmos->rst_gpio, 1);
-
-	msleep(500);
-
-	gpiod_set_value_cansleep(addicmos->rst_gpio, 0);
-
-	/* Set SPI pins to SPI mode */
-	ret = pinctrl_select_state(addicmos->pinctrl, addicmos->pins_spi);
-	if (ret < 0)
-		return ret;
-
-	ret = regmap_read(addicmos->regmap, 0x112, &read_val);
-	if (ret < 0) {
-		dev_err(addicmos->dev, "Read of Chip ID register failed.\n");
-		return ret;
-	}
-
-	if (read_val != 0x5931) {
-		dev_err(addicmos->dev, "Chip ID: %.4X is wrong.\n", read_val);
-		return -ENXIO;
-	}
-	dev_dbg(addicmos->dev, "Read Chip ID: %.4X\n", read_val);
-
-	return 0;
-}
-
-static int addicmos_g_sensor_firmware(struct v4l2_subdev *sd)
-{
-	struct addicmos *addicmos = to_addicmos(sd);
-	const struct firmware *fw = addicmos->fw;
-	const struct addicmos_fw_header *fw_head;
-	unsigned int reg_nr, modes_nr, data_size_bytes, i, j;
-
-	if (fw->size < sizeof(struct addicmos_fw_header) ||
-	    fw->size >= 0x4000000)
-		goto err_size;
-
-	fw_head = (struct addicmos_fw_header *)fw->data;
-
-	if (memcmp(fw_head->magic, ADDI_MAGIC, ARRAY_SIZE(fw_head->magic))) {
-		dev_err(addicmos->dev, "FW loading failed: Invalid magic\n");
-		return -EINVAL;
-	}
-
-	modes_nr = le32_to_cpu(fw_head->modes_nr);
-	if (modes_nr == 0) {
-		dev_err(addicmos->dev, "FW should contain at least 1 mode.\n");
-		return -EINVAL;
-	}
-
-	__v4l2_ctrl_modify_range(addicmos->operating_mode,
-				 addicmos->operating_mode->minimum,
-				 modes_nr - 1, 1, 0);
-
-	data_size_bytes = le32_to_cpu(fw_head->data_size_bytes);
-	reg_nr = data_size_bytes / sizeof(uint16_t) / 2;
-	addicmos->fw_regs_count = reg_nr;
-
-	addicmos->fw_regs = devm_kcalloc(addicmos->dev, reg_nr,
-			       sizeof(struct reg_sequence), GFP_KERNEL);
-	if (!addicmos->fw_regs)
-		return -ENOMEM;
-
-	for (i = 0, j = 0; i < reg_nr * 2; i += 2, j++) {
-		addicmos->fw_regs[j].reg = le16_to_cpu(fw_head->data[i]);
-		addicmos->fw_regs[j].def = le16_to_cpu(fw_head->data[i + 1]);
-	}
-
-	return 0;
-
-err_size:
-	dev_err(addicmos->dev, "FW loading failed: Invalid size\n");
-	return -EINVAL;
-}
-
-static int addicmos_firmware_load(struct v4l2_subdev *sd)
-{
-	struct addicmos *addicmos = to_addicmos(sd);
-	int ret = 0;
-
-	if (fw_load) {
-		ret = request_firmware(&addicmos->fw, FW_FILE_NAME, addicmos->dev);
-		if (ret < 0) {
-			dev_err(addicmos->dev, "FW request failed\n");
-			goto release_firmware;
-		}
-
-		ret = addicmos_g_sensor_firmware(sd);
-		if (ret < 0) {
-			dev_err(addicmos->dev, "FW parsing failed\n");
-			goto release_firmware;
-		}
-
-		/* Writes for Default firmware */
-		regmap_multi_reg_write(addicmos->regmap, addicmos->fw_regs,
-					     addicmos->fw_regs_count);
-	}
-
-	if (calib_load) {
-		/* Writes for Default calibration */
-		regmap_multi_reg_write(addicmos->regmap,
-				       addicmos_powerup_setting,
-				       ARRAY_SIZE(addicmos_powerup_setting));
-	}
-
-release_firmware:
-	release_firmware(addicmos->fw);
-	return ret;
-}
-
-static int addicmos_probe(struct spi_device *client)
-{
-	struct v4l2_fwnode_endpoint bus_cfg = {
-		.bus_type = V4L2_MBUS_CSI2_DPHY
-	};
-	struct device *dev = &client->dev;
-	struct fwnode_handle *endpoint;
-	struct addicmos *addicmos;
-	struct pwm_state state;
-	int ret;
-
-	addicmos = devm_kzalloc(dev, sizeof(struct addicmos), GFP_KERNEL);
-	if (!addicmos)
-		return -ENOMEM;
-
-	addicmos->dev = dev;
-
-	addicmos->regmap = devm_regmap_init(dev, &addicmos_spi_bus_config, dev,
-					    &addicmos_spi_regmap_config);
-	if (IS_ERR(addicmos->regmap)) {
-		dev_err(dev, "Error initializing spi regmap\n");
-		return PTR_ERR(addicmos->regmap);
-	}
-
-	mutex_init(&addicmos->lock);
-
-	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
-	if (!endpoint) {
-		dev_err(dev, "endpoint node not found\n");
-		return -EINVAL;
-	}
-
-	ret = v4l2_fwnode_endpoint_parse(endpoint, &bus_cfg);
-	fwnode_handle_put(endpoint);
-	if (ret < 0) {
-		dev_err(dev, "parsing endpoint node failed\n");
-		return ret;
-	}
-
-	addicmos->rst_gpio = gpiod_get(dev, "reset", GPIOD_OUT_LOW);
-	if (IS_ERR(addicmos->rst_gpio)) {
-		dev_err(dev, "Unable to get \"reset\" gpio\n");
-		return PTR_ERR(addicmos->rst_gpio);
-	}
-
-	addicmos->pinctrl = devm_pinctrl_get(dev);
-	if (IS_ERR(addicmos->pinctrl)) {
-		dev_err(dev, "Unable to get \"pinctrl\" block\n");
-		return PTR_ERR(addicmos->pinctrl);
-	}
-
-	addicmos->pins_spi = pinctrl_lookup_state(addicmos->pinctrl, "spi");
-	if (IS_ERR(addicmos->pins_spi)) {
-		dev_err(dev, "Unable to get \"spi-pinctrl\" block\n");
-		return PTR_ERR(addicmos->pins_spi);
-	}
-
-	addicmos->pins_gpio = pinctrl_lookup_state(addicmos->pinctrl, "gpio");
-	if (IS_ERR(addicmos->pins_gpio)) {
-		dev_err(dev, "Unable to get \"gpio-pinctrl\" block\n");
-		return PTR_ERR(addicmos->pins_gpio);
-	}
-
-	ret = addicmos_spi_bus_init(&addicmos->sd);
-	if (ret) {
-		dev_err(dev, "%s: SPI bus initialization failed %d\n",
-			__func__, ret);
-		goto release_gpio;
-	}
-
-	addicmos->pwm_fsync = devm_pwm_get(dev, NULL);
-	if (IS_ERR(addicmos->pwm_fsync)) {
-		dev_err(dev, "Failed to get pwm device\n");
-		return PTR_ERR(addicmos->pwm_fsync);
-	}
-
-	/* Get PWM state. */
-	pwm_init_state(addicmos->pwm_fsync, &state);
-	pwm_set_relative_duty_cycle(&state, 50, 100);
-	ret = pwm_apply_state(addicmos->pwm_fsync, &state);
-	if (ret) {
-		dev_err(dev, "%s: PWM init failed %d\n",
-			__func__, ret);
-		goto release_gpio;
-	}
-
-	v4l2_ctrl_handler_init(&addicmos->ctrls, 3);
-
-	addicmos->pixel_rate = v4l2_ctrl_new_std(&addicmos->ctrls,
-						  &addicmos_ctrl_ops,
-						  V4L2_CID_PIXEL_RATE,
-						  1, INT_MAX, 1, 1);
-	addicmos->link_freq = v4l2_ctrl_new_int_menu(&addicmos->ctrls,
-						     &addicmos_ctrl_ops,
-						     V4L2_CID_LINK_FREQ,
-						     ARRAY_SIZE(
-							     link_freq_tbl) - 1,
-						     0, link_freq_tbl);
-	if (addicmos->link_freq)
-		addicmos->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
-
-	addicmos->operating_mode = v4l2_ctrl_new_custom(&addicmos->ctrls,
-						&addicmos_ctrl_operating_mode,
-						NULL);
-
-	addicmos->set_chip_config = v4l2_ctrl_new_custom(&addicmos->ctrls,
-						&addicmos_ctrl_chip_config,
-						NULL);
-
-	ret = addicmos->ctrls.error;
-	if (ret) {
-		dev_err(dev, "%s: control initialization error %d\n",
-			__func__, ret);
-		goto free_ctrl;
-	}
-	addicmos->sd.ctrl_handler = &addicmos->ctrls;
-
-	v4l2_spi_subdev_init(&addicmos->sd, client, &addicmos_subdev_ops);
-	addicmos->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-	addicmos->pad.flags = MEDIA_PAD_FL_SOURCE;
-	addicmos->sd.dev = &client->dev;
-	addicmos->sd.entity.ops = &addicmos_subdev_entity_ops;
-	addicmos->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
-
-	ret = media_entity_pads_init(&addicmos->sd.entity, 1, &addicmos->pad);
-	if (ret < 0) {
-		dev_err(dev, "could not register media entity\n");
-		goto free_ctrl;
-	}
-
-	ret = addicmos_firmware_load(&addicmos->sd);
-	if (ret < 0)
-		return ret;
-
-	addicmos_entity_init_cfg(&addicmos->sd, NULL);
-
-	ret = v4l2_async_register_subdev(&addicmos->sd);
-	if (ret < 0) {
-		dev_err(dev, "could not register v4l2 device\n");
-		goto free_entity;
-	}
-
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-	pm_runtime_idle(dev);
-
-	return 0;
-
-free_entity:
-	media_entity_cleanup(&addicmos->sd.entity);
-free_ctrl:
-	v4l2_ctrl_handler_free(&addicmos->ctrls);
-	mutex_destroy(&addicmos->lock);
-release_gpio:
-	gpiod_put(addicmos->rst_gpio);
-
-	return ret;
-}
-
-static int addicmos_remove(struct spi_device *client)
-{
-	struct v4l2_subdev *sd = spi_get_drvdata(client);
-	struct addicmos *addicmos = to_addicmos(sd);
-
-	v4l2_async_unregister_subdev(&addicmos->sd);
-	media_entity_cleanup(&addicmos->sd.entity);
-	gpiod_put(addicmos->rst_gpio);
-	v4l2_ctrl_handler_free(&addicmos->ctrls);
-	mutex_destroy(&addicmos->lock);
-
-	pm_runtime_disable(addicmos->dev);
-	if (!pm_runtime_status_suspended(addicmos->dev))
-		addicmos_power_off(addicmos->dev);
-	pm_runtime_set_suspended(addicmos->dev);
-
-	return 0;
-}
-
-static const struct of_device_id addicmos_of_match[] = {
-	{ .compatible = "adi,addicmos" },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, addicmos_of_match);
-
-static const struct spi_device_id addicmos_ids[] = {
-	{ "addicmos", 0 },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(spi, addicmos_ids);
-
-static struct spi_driver addicmos_spi_driver = {
-	.driver			= {
-		.of_match_table = addicmos_of_match,
-		.name		= "addicmos",
-		.pm		= &addicmos_pm_ops,
-	},
-	.probe			= addicmos_probe,
-	.remove			= addicmos_remove,
-	.id_table		= addicmos_ids,
-};
-
-module_spi_driver(addicmos_spi_driver);
-
-MODULE_DESCRIPTION("Analog Devices ADDICMOS Camera Driver");
-MODULE_AUTHOR("Bogdan Togorean");
-MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/spi/adsd3100.c b/drivers/media/spi/adsd3100.c
new file mode 100644
index 000000000000..2c04599266e0
--- /dev/null
+++ b/drivers/media/spi/adsd3100.c
@@ -0,0 +1,1117 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for the Analog Devices ADSD3100 ToF camera sensor.
+ *
+ * Copyright (C) 2019-2020 Analog Devices, All Rights Reserved.
+ *
+ */
+
+#include <linux/gpio/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pwm.h>
+#include <linux/firmware.h>
+#include <linux/spi/spi.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#define FW_FILE_NAME	"adi/adsd3100-fw.bin"
+#define ADI_MAGIC	"ADDICMOS"
+
+static bool fw_load = false;
+module_param(fw_load, bool, 0644);
+MODULE_PARM_DESC(fw_load, "Boolean enabling/disabling FW loading by driver");
+
+static bool calib_load = false;
+module_param(calib_load, bool, 0644);
+MODULE_PARM_DESC(calib_load, "Boolean enabling/disabling LXDAC loading by driver");
+
+struct adsd3100_mode_info {
+	u32 width;
+	u32 height;
+	u32 pixel_rate;
+	u32 link_freq_idx;
+};
+
+struct adsd3100_mode_fw_block {
+	const struct reg_sequence *mode_regs;
+	ssize_t regs_count;
+};
+
+struct adsd3100_fw_header {
+	unsigned char magic[8];
+	__le32 modes_nr;
+	__le32 data_size_bytes;
+	__le16 data[];
+} __packed;
+
+struct adsd3100 {
+	struct regmap *regmap;
+	struct device *dev;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt fmt;
+	struct v4l2_rect crop;
+
+	const struct adsd3100_mode_info *current_mode;
+
+	struct v4l2_ctrl_handler ctrls;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *link_freq;
+	/* custom controls */
+	struct v4l2_ctrl *operating_mode;
+	struct v4l2_ctrl *set_chip_config;
+
+	struct mutex lock;
+	bool streaming;
+
+	struct gpio_desc *rst_gpio;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_spi, *pins_gpio;
+
+	struct pwm_device *pwm_fsync;
+
+	/* FW related data */
+	int fw_regs_count;
+	struct reg_sequence *fw_regs;
+	u8 curr_operating_mode;
+
+	const struct firmware *fw;
+};
+
+static inline struct adsd3100 *to_adsd3100(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct adsd3100, sd);
+}
+
+#define V4L2_CID_ADSD3100_OPERATING_MODE	(V4L2_CID_USER_ADSD_BASE + 0)
+#define V4L2_CID_ADSD3100_CHIP_CONFIG		(V4L2_CID_USER_ADSD_BASE + 1)
+
+static const struct reg_sequence adsd3100_powerup_setting[] = {
+	{ 0x0000, 0x1d29 },
+	{ 0x0002, 0x43d1 },
+	{ 0x0000, 0x1d25 },
+	{ 0x0002, 0x0000 },
+	{ 0x0000, 0x1c99 },
+	{ 0x0002, 0x0069 },
+	{ 0x0002, 0x0060 },
+	{ 0x0002, 0x0061 },
+	{ 0x0002, 0x0307 },
+	{ 0x0002, 0x0069 },
+	{ 0x0002, 0x0105 },
+	{ 0x0002, 0x0000 },
+	{ 0x0002, 0x0069 },
+	{ 0x0002, 0x0060 },
+	{ 0x0002, 0x0061 },
+	{ 0x0002, 0x0307 },
+	{ 0x0002, 0x0000 },
+	{ 0x0002, 0x0000 },
+	{ 0x0002, 0x0000 },
+	{ 0x0002, 0x0303 },
+	{ 0x0002, 0x0069 },
+	{ 0x0002, 0x0060 },
+	{ 0x0002, 0x0061 },
+	{ 0x0002, 0x0307 },
+	{ 0x0002, 0x0060 },
+	{ 0x0002, 0x0059 },
+	{ 0x0002, 0x0059 },
+	{ 0x0002, 0x0301 },
+	{ 0x0002, 0x0000 },
+	{ 0x0002, 0x006f },
+	{ 0x0002, 0x0105 },
+	{ 0x0002, 0x006e },
+	{ 0x0002, 0x0067 },
+	{ 0x0002, 0x0063 },
+	{ 0x0002, 0x0301 },
+	{ 0x0002, 0x0068 },
+	{ 0x0002, 0x006e },
+	{ 0x0002, 0x0205 },
+	{ 0x0002, 0x646b },
+	{ 0x0002, 0x0021 },
+	{ 0x0172, 0x0a0a },
+	{ 0x0132, 0x0047 },
+	{ 0x0126, 0x0020 },
+	{ 0x0132, 0x0088 },
+	{ 0x0126, 0x0001 },
+	{ 0x0132, 0x001d },
+	{ 0x0126, 0x0008 },
+	{ 0x0132, 0x008b },
+	{ 0x0126, 0x0010 },
+	{ 0x0132, 0x0075 },
+	{ 0x0126, 0x0040 },
+	{ 0x0246, 0xc1fa },
+	{ 0x0102, 0x019e },
+	{ 0x0104, 0x009a },
+	{ 0x012e, 0x060a },
+	{ 0x0130, 0x1f10 },
+	{ 0x0520, 0x1a00 },
+	{ 0x0522, 0x1627 },
+	{ 0x0524, 0x1321 },
+	{ 0x0526, 0x0a8a },
+};
+
+static const struct reg_sequence adsd3100_powerdown_setting[] = {
+};
+
+static const struct reg_sequence adsd3100_standby_setting[] = {
+};
+
+static const s64 link_freq_tbl[] = {
+	732000000,
+	732000000,
+	732000000,
+	732000000,
+	732000000,
+	732000000
+};
+
+/* Elements of the structure must be ordered ascending by width & height */
+static const struct adsd3100_mode_info adsd3100_mode_info_data[] = {
+	{
+		.width = 3840,
+		.height = 216,
+		.pixel_rate = 488000000,
+		.link_freq_idx = 0 /* an index in link_freq_tbl[] */
+	},
+	{
+		.width = 4096,
+		.height = 64,
+		.pixel_rate = 488000000,
+		.link_freq_idx = 1 /* an index in link_freq_tbl[] */
+	},
+	{
+		.width = 4096,
+		.height = 256,
+		.pixel_rate = 488000000,
+		.link_freq_idx = 2 /* an index in link_freq_tbl[] */
+	},
+	{
+		.width = 4096,
+		.height = 640,
+		.pixel_rate = 488000000,
+		.link_freq_idx = 3 /* an index in link_freq_tbl[] */
+	},
+	{
+		.width = 4096,
+		.height = 2304,
+		.pixel_rate = 488000000,
+		.link_freq_idx = 4 /* an index in link_freq_tbl[] */
+	},
+	{
+		.width = 4096,
+		.height = 2560,
+		.pixel_rate = 488000000,
+		.link_freq_idx = 5 /* an index in link_freq_tbl[] */
+	}
+};
+
+static int adsd3100_regmap_write(void *context, const void *data, size_t count)
+{
+	struct device *dev = context;
+	struct spi_device *spi = to_spi_device(dev);
+
+	return spi_write(spi, data, count);
+}
+
+static int adsd3100_regmap_read(void *context,
+				const void *reg, size_t reg_size,
+				void *val, size_t val_size)
+{
+	struct device *dev = context;
+	struct spi_device *spi = to_spi_device(dev);
+	u16 *rx_buf;
+
+	/* First response word should be ignored so allocate more & discard */
+	rx_buf = (u16*)kmalloc(val_size + sizeof(u16), GFP_KERNEL);
+	if (!rx_buf)
+		return -ENOMEM;
+
+	spi_write_then_read(spi, reg, reg_size, rx_buf, val_size + sizeof(u16));
+	memcpy(val, rx_buf + 1, val_size);
+
+	kfree(rx_buf);
+	return 0;
+}
+
+static bool adsd3100_regmap_accessible_reg(struct device *dev, unsigned int reg)
+{
+	if (reg % 2)
+		return 0;
+
+	if ((reg >= 0x000) && (reg <= 0x294))
+		return 1;
+	else if ((reg >= 0x300) && (reg <= 0x83e))
+		return 1;
+	else if ((reg >= 0x900) && (reg <= 0xefe))
+		return 1;
+	else
+		return 0;
+}
+
+static struct regmap_bus adsd3100_spi_bus_config = {
+	.write = adsd3100_regmap_write,
+	.read = adsd3100_regmap_read,
+	.read_flag_mask = 0x00,
+	.reg_format_endian_default = REGMAP_ENDIAN_BIG,
+	.val_format_endian_default = REGMAP_ENDIAN_BIG,
+};
+
+static const struct regmap_config adsd3100_spi_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 16,
+	.max_register = 0xefe,
+	.read_flag_mask = 0x00,
+	.write_flag_mask = 0x80,
+	.cache_type = REGCACHE_NONE,
+	.readable_reg = adsd3100_regmap_accessible_reg,
+};
+
+static int adsd3100_power_on(struct device *dev)
+{
+	struct spi_device *client = to_spi_device(dev);
+	struct v4l2_subdev *sd = spi_get_drvdata(client);
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+	unsigned int read_val;
+	int i, ret;
+
+	dev_dbg(adsd3100->dev, "Entered adsd3100_power_on\n");
+
+	ret = regmap_write(adsd3100->regmap, 0xC, 0xC5);
+	if (ret)
+		dev_err(adsd3100->dev, "Could not set power up register\n");
+
+	for (i = 0; i < 10; i ++) {
+		msleep_interruptible(15);
+		regmap_read(adsd3100->regmap, 0x256, &read_val);
+		if (read_val == 0x2) {
+			return 0;
+		}
+	}
+
+	dev_err(adsd3100->dev, "Power on timed out.\n");
+	dev_dbg(adsd3100->dev, "Status register 0x256 value: %x\n", read_val);
+	regmap_read(adsd3100->regmap, 0x32, &read_val);
+	dev_dbg(adsd3100->dev, "Status register 0x32 value: %x\n", read_val);
+
+	return -ETIME;
+}
+
+static int adsd3100_power_off(struct device *dev)
+{
+	struct spi_device *client = to_spi_device(dev);
+	struct v4l2_subdev *sd = spi_get_drvdata(client);
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+	unsigned int read_val;
+	int i, ret;
+
+	if (!adsd3100->streaming)
+		return 0;
+
+	dev_dbg(adsd3100->dev, "Entered adsd3100_power_off\n");
+
+	ret = regmap_write(adsd3100->regmap, 0xC, 0x2);
+	if (ret)
+		dev_err(adsd3100->dev, "Could not set power down register\n");
+
+	for (i = 0; i < 5; i ++) {
+		msleep_interruptible(100);
+		regmap_read(adsd3100->regmap, 0xC, &read_val);
+		if (read_val == 0x0) {
+			return 0;
+		}
+	}
+
+	pwm_disable(adsd3100->pwm_fsync);
+	dev_err(adsd3100->dev, "Power off timed out.\n");
+	regmap_read(adsd3100->regmap, 0x32, &read_val);
+	dev_dbg(adsd3100->dev, "Status register 0x32 value: %x\n", read_val);
+
+	return -ETIME;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int adsd3100_g_register(struct v4l2_subdev *sd,
+			       struct v4l2_dbg_register *reg)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+	unsigned int read_val;
+	int ret;
+
+	reg->size = 2;
+	ret = regmap_read(adsd3100->regmap, reg->reg, &read_val);
+	reg->val = read_val;
+
+	return ret;
+}
+
+static int adsd3100_s_register(struct v4l2_subdev *sd,
+			       const struct v4l2_dbg_register *reg)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+
+	return regmap_write(adsd3100->regmap, reg->reg, reg->val);
+}
+#endif
+
+static int adsd3100_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+
+	dev_dbg(adsd3100->dev, "%s: %d\n", __func__, on);
+	return 0;
+}
+
+static int adsd3100_chip_config(struct adsd3100 *adsd3100,
+				    struct v4l2_ctrl *ctrl)
+{
+	uint16_t *val, *reg, val_nr, i;
+	bool burst;
+	int ret;
+
+	burst = *(ctrl->p_new.p_u16);
+	val_nr = *(ctrl->p_new.p_u16 + 1);
+	val = ctrl->p_new.p_u16 + 2;
+	reg = val + val_nr;
+
+	dev_dbg(adsd3100->dev, "Entered adsd3100_chip_config. ADDR: %x VAL_NR %d \n", *reg, val_nr);
+
+	if (*reg & 0x8000) { /* 0x8000 - write mask */
+		if (burst)
+			ret = regmap_bulk_write(adsd3100->regmap, *reg, val, val_nr);
+		else
+			for (i=0; i<val_nr; i++)
+				ret = regmap_bulk_write(adsd3100->regmap, *(reg + i), val + i, 1);
+		if (ret)
+			dev_warn(adsd3100->dev,
+				"could not write to register %x\n", *reg);
+	} else {
+		if (burst)
+			ret = regmap_bulk_read(adsd3100->regmap, *reg, val, val_nr);
+		else
+			for (i=0; i<val_nr; i++)
+				ret = regmap_bulk_read(adsd3100->regmap, *(reg + i), val + i, 1);
+		if (ret)
+			dev_warn(adsd3100->dev,
+				"could not read from register %x\n", *reg);
+	}
+
+	return 0;
+}
+
+static int adsd3100_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct adsd3100 *adsd3100 = container_of(ctrl->handler,
+						 struct adsd3100, ctrls);
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ADSD3100_OPERATING_MODE:
+		adsd3100->curr_operating_mode = ctrl->val;
+		break;
+	case V4L2_CID_ADSD3100_CHIP_CONFIG:
+		ret = adsd3100_chip_config(adsd3100, ctrl);
+		break;
+	case V4L2_CID_PIXEL_RATE:
+	case V4L2_CID_LINK_FREQ:
+		break;
+	default:
+		dev_err(adsd3100->dev, "%s > Unhandled: %x  param=%x\n",
+			__func__, ctrl->id, ctrl->val);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops adsd3100_ctrl_ops = {
+	.s_ctrl = adsd3100_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config adsd3100_ctrl_chip_config = {
+	.ops		= &adsd3100_ctrl_ops,
+	.id		= V4L2_CID_ADSD3100_CHIP_CONFIG,
+	.name		= "Chip Config",
+	.type		= V4L2_CTRL_TYPE_U16,
+	.def		= 0xFF,
+	.min		= 0x00,
+	.max		= 0xFFFF,
+	.step		= 1,
+	.dims		= { 65537 },
+};
+
+static const struct v4l2_ctrl_config adsd3100_ctrl_operating_mode = {
+	.ops		= &adsd3100_ctrl_ops,
+	.id		= V4L2_CID_ADSD3100_OPERATING_MODE,
+	.name		= "Operating Mode",
+	.type		= V4L2_CTRL_TYPE_INTEGER,
+	.def		= 0,
+	.min		= 0,
+	.max		= 10,
+	.step		= 1,
+};
+
+static int adsd3100_enum_mbus_code(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_pad_config *cfg,
+				   struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SBGGR12_1X12;
+
+	return 0;
+}
+
+static int adsd3100_enum_frame_size(struct v4l2_subdev *subdev,
+				    struct v4l2_subdev_pad_config *cfg,
+				    struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->code != MEDIA_BUS_FMT_SBGGR12_1X12)
+		return -EINVAL;
+
+	if (fse->index >= ARRAY_SIZE(adsd3100_mode_info_data))
+		return -EINVAL;
+
+	fse->min_width = adsd3100_mode_info_data[fse->index].width;
+	fse->max_width = adsd3100_mode_info_data[fse->index].width;
+	fse->min_height = adsd3100_mode_info_data[fse->index].height;
+	fse->max_height = adsd3100_mode_info_data[fse->index].height;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+adsd3100_get_pad_format(struct adsd3100 *adsd3100,
+			struct v4l2_subdev_pad_config *cfg, unsigned int pad,
+			enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&adsd3100->sd, cfg, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &adsd3100->fmt;
+	default:
+		return ERR_PTR(-EINVAL);
+	}
+}
+
+static int adsd3100_get_format(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_format *format)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+	struct v4l2_mbus_framefmt *pad_format;
+
+	pad_format = adsd3100_get_pad_format(adsd3100, cfg, format->pad,
+					     format->which);
+	if (IS_ERR(pad_format))
+		return PTR_ERR(pad_format);
+
+	format->format = *pad_format;
+
+	return 0;
+}
+
+static struct v4l2_rect *
+adsd3100_get_pad_crop(struct adsd3100 *adsd3100,
+		      struct v4l2_subdev_pad_config *cfg,
+		      unsigned int pad, enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_crop(&adsd3100->sd, cfg, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &adsd3100->crop;
+	default:
+		return ERR_PTR(-EINVAL);
+	}
+}
+
+static int adsd3100_set_format(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_format *format)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+	struct v4l2_mbus_framefmt *framefmt;
+	struct v4l2_rect *crop;
+	const struct adsd3100_mode_info *new_mode;
+	int ret;
+
+	dev_dbg(adsd3100->dev, "set_fmt: %x %dx%d %d\n",
+		format->format.code, format->format.width,
+		format->format.height, format->which);
+
+	mutex_lock(&adsd3100->lock);
+
+	crop = adsd3100_get_pad_crop(adsd3100, cfg, format->pad,
+				     format->which);
+	if (IS_ERR(crop))
+		return PTR_ERR(crop);
+
+	new_mode = v4l2_find_nearest_size(adsd3100_mode_info_data,
+					  ARRAY_SIZE(adsd3100_mode_info_data),
+					  width, height, format->format.width,
+					  format->format.height);
+	crop->width = new_mode->width;
+	crop->height = new_mode->height;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		ret = v4l2_ctrl_s_ctrl_int64(adsd3100->pixel_rate,
+					     new_mode->pixel_rate);
+		if (ret < 0)
+			return ret;
+
+		ret = v4l2_ctrl_s_ctrl(adsd3100->link_freq,
+				       new_mode->link_freq_idx);
+		if (ret < 0)
+			return ret;
+
+		adsd3100->current_mode = new_mode;
+	}
+
+	framefmt = adsd3100_get_pad_format(adsd3100, cfg, format->pad,
+					   format->which);
+	if (IS_ERR(framefmt))
+		return PTR_ERR(framefmt);
+
+	framefmt->width = crop->width;
+	framefmt->height = crop->height;
+	framefmt->code = MEDIA_BUS_FMT_SBGGR12_1X12;
+	framefmt->field = V4L2_FIELD_NONE;
+	framefmt->colorspace = V4L2_COLORSPACE_RAW;
+
+	format->format = *framefmt;
+
+	mutex_unlock(&adsd3100->lock);
+
+	return 0;
+}
+
+static int adsd3100_entity_init_cfg(struct v4l2_subdev *subdev,
+				    struct v4l2_subdev_pad_config *cfg)
+{
+	struct v4l2_subdev_format fmt = { 0 };
+
+	fmt.which = cfg ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.format.width = adsd3100_mode_info_data[0].width;
+	fmt.format.height = adsd3100_mode_info_data[0].height;
+
+	adsd3100_set_format(subdev, cfg, &fmt);
+
+	return 0;
+}
+
+static int adsd3100_get_selection(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_selection *sel)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+	struct v4l2_rect *crop;
+
+	if (sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	crop = adsd3100_get_pad_crop(adsd3100, cfg, sel->pad, sel->which);
+	if (IS_ERR(crop))
+		return PTR_ERR(crop);
+
+	sel->r = *crop;
+
+	return 0;
+}
+
+static int adsd3100_start_streaming(struct adsd3100 *adsd3100)
+{
+	unsigned int read_val;
+	int ret;
+
+	regmap_read(adsd3100->regmap, 0x210, &read_val);
+	if (read_val != adsd3100->curr_operating_mode) {
+		ret = regmap_write(adsd3100->regmap, 0x200,
+				   adsd3100->curr_operating_mode);
+		if (ret)
+			dev_err(adsd3100->dev, "Could not set mode register\n");
+		/* Reduce line width only for mode 1 */
+		if (adsd3100->curr_operating_mode == 1)
+			ret = regmap_write(adsd3100->regmap, 0x27e,0x8006);
+		else
+			ret = regmap_write(adsd3100->regmap, 0x27e,0x0);
+	}
+
+	ret = pwm_enable(adsd3100->pwm_fsync);
+	if (ret)
+		dev_err(adsd3100->dev, "Could not enable FSYNC PWM\n");
+
+	adsd3100->streaming = true;
+
+	return ret;
+}
+
+static int adsd3100_stop_streaming(struct adsd3100 *adsd3100)
+{
+	pwm_disable(adsd3100->pwm_fsync);
+	adsd3100->streaming = false;
+
+	return 0;
+}
+
+static int adsd3100_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(subdev);
+	int ret = 0;
+
+	dev_dbg(adsd3100->dev, "s_stream: %d\n", enable);
+
+	mutex_lock(&adsd3100->lock);
+	if (adsd3100->streaming == enable) {
+		mutex_unlock(&adsd3100->lock);
+		return 0;
+	}
+
+	if (enable) {
+		ret = pm_runtime_get_sync(adsd3100->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(adsd3100->dev);
+			goto err_unlock;
+		}
+
+		ret = adsd3100_start_streaming(adsd3100);
+		if (ret)
+			goto err_rpm_put;
+	} else {
+		adsd3100_stop_streaming(adsd3100);
+		pm_runtime_put(adsd3100->dev);
+	}
+
+	mutex_unlock(&adsd3100->lock);
+
+	return ret;
+
+err_rpm_put:
+	pm_runtime_put(adsd3100->dev);
+err_unlock:
+	mutex_unlock(&adsd3100->lock);
+
+	return ret;
+}
+
+static int adsd3100_g_frame_interval(struct v4l2_subdev *subdev,
+				     struct v4l2_subdev_frame_interval *fi)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(subdev);
+	struct pwm_state state;
+
+	/* Sync up PWM state. */
+	pwm_init_state(adsd3100->pwm_fsync, &state);
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator =
+		(u32)(NSEC_PER_SEC / pwm_get_period(adsd3100->pwm_fsync));
+	dev_dbg(adsd3100->dev, "%s frame rate = %u / %u\n", __func__,
+		fi->interval.numerator, fi->interval.denominator);
+
+	return 0;
+}
+
+static int adsd3100_s_frame_interval(struct v4l2_subdev *subdev,
+				     struct v4l2_subdev_frame_interval *fi)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(subdev);
+	struct pwm_state state;
+	int ret = 0;
+
+	mutex_lock(&adsd3100->lock);
+
+	/* Get PWM state. */
+	pwm_init_state(adsd3100->pwm_fsync, &state);
+	state.period = DIV_ROUND_UP(fi->interval.numerator * NSEC_PER_SEC,
+				    fi->interval.denominator);
+	pwm_set_relative_duty_cycle(&state, 50, 100);
+	ret = pwm_apply_state(adsd3100->pwm_fsync, &state);
+
+	dev_dbg(adsd3100->dev, "Set frame interval to %u / %u\n",
+		fi->interval.numerator, fi->interval.denominator);
+
+	mutex_unlock(&adsd3100->lock);
+
+	return ret;
+}
+
+static int adsd3100_link_setup(struct media_entity *entity,
+			   const struct media_pad *local,
+			   const struct media_pad *remote, u32 flags)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops adsd3100_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register	= adsd3100_g_register,
+	.s_register	= adsd3100_s_register,
+#endif
+	.s_power = adsd3100_s_power,
+};
+
+static const struct dev_pm_ops adsd3100_pm_ops = {
+	SET_RUNTIME_PM_OPS(adsd3100_power_off, adsd3100_power_on, NULL)
+};
+
+static const struct v4l2_subdev_video_ops adsd3100_video_ops = {
+	.s_stream		= adsd3100_s_stream,
+	.g_frame_interval	= adsd3100_g_frame_interval,
+	.s_frame_interval	= adsd3100_s_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops adsd3100_subdev_pad_ops = {
+	.init_cfg		= adsd3100_entity_init_cfg,
+	.enum_mbus_code		= adsd3100_enum_mbus_code,
+	.enum_frame_size	= adsd3100_enum_frame_size,
+	.get_fmt		= adsd3100_get_format,
+	.set_fmt		= adsd3100_set_format,
+	.get_selection		= adsd3100_get_selection,
+};
+
+static const struct v4l2_subdev_ops adsd3100_subdev_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.core	= &adsd3100_core_ops,
+#endif
+	.video	= &adsd3100_video_ops,
+	.pad	= &adsd3100_subdev_pad_ops,
+};
+
+static const struct media_entity_operations adsd3100_subdev_entity_ops = {
+	.link_setup = adsd3100_link_setup,
+};
+
+static int adsd3100_spi_bus_init(struct v4l2_subdev *sd)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+	unsigned int read_val;
+	int ret;
+
+	/* Set SPI pins to GPIO mode */
+	ret = pinctrl_select_state(adsd3100->pinctrl, adsd3100->pins_gpio);
+	if (ret < 0)
+		return ret;
+
+	gpiod_set_value_cansleep(adsd3100->rst_gpio, 1);
+
+	msleep(500);
+
+	gpiod_set_value_cansleep(adsd3100->rst_gpio, 0);
+
+	/* Set SPI pins to SPI mode */
+	ret = pinctrl_select_state(adsd3100->pinctrl, adsd3100->pins_spi);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_read(adsd3100->regmap, 0x112, &read_val);
+	if (ret < 0) {
+		dev_err(adsd3100->dev, "Read of Chip ID register failed.\n");
+		return ret;
+	}
+
+	if (read_val != 0x5931) {
+		dev_err(adsd3100->dev, "Chip ID: %.4X is wrong.\n", read_val);
+		return -ENXIO;
+	}
+	dev_dbg(adsd3100->dev, "Read Chip ID: %.4X\n", read_val);
+
+	return 0;
+}
+
+static int adsd3100_g_sensor_firmware(struct v4l2_subdev *sd)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+	const struct firmware *fw = adsd3100->fw;
+	const struct adsd3100_fw_header *fw_head;
+	unsigned int reg_nr, modes_nr, data_size_bytes, i, j;
+
+	if (fw->size < sizeof(struct adsd3100_fw_header) ||
+	    fw->size >= 0x4000000)
+		goto err_size;
+
+	fw_head = (struct adsd3100_fw_header *)fw->data;
+
+	if (memcmp(fw_head->magic, ADI_MAGIC, ARRAY_SIZE(fw_head->magic))) {
+		dev_err(adsd3100->dev, "FW loading failed: Invalid magic\n");
+		return -EINVAL;
+	}
+
+	modes_nr = le32_to_cpu(fw_head->modes_nr);
+	if (modes_nr == 0) {
+		dev_err(adsd3100->dev, "FW should contain at least 1 mode.\n");
+		return -EINVAL;
+	}
+
+	__v4l2_ctrl_modify_range(adsd3100->operating_mode,
+				 adsd3100->operating_mode->minimum,
+				 modes_nr - 1, 1, 0);
+
+	data_size_bytes = le32_to_cpu(fw_head->data_size_bytes);
+	reg_nr = data_size_bytes / sizeof(uint16_t) / 2;
+	adsd3100->fw_regs_count = reg_nr;
+
+	adsd3100->fw_regs = devm_kcalloc(adsd3100->dev, reg_nr,
+			       sizeof(struct reg_sequence), GFP_KERNEL);
+	if (!adsd3100->fw_regs)
+		return -ENOMEM;
+
+	for (i = 0, j = 0; i < reg_nr * 2; i += 2, j++) {
+		adsd3100->fw_regs[j].reg = le16_to_cpu(fw_head->data[i]);
+		adsd3100->fw_regs[j].def = le16_to_cpu(fw_head->data[i + 1]);
+	}
+
+	return 0;
+
+err_size:
+	dev_err(adsd3100->dev, "FW loading failed: Invalid size\n");
+	return -EINVAL;
+}
+
+static int adsd3100_firmware_load(struct v4l2_subdev *sd)
+{
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+	int ret = 0;
+
+	if (fw_load) {
+		ret = request_firmware(&adsd3100->fw, FW_FILE_NAME, adsd3100->dev);
+		if (ret < 0) {
+			dev_err(adsd3100->dev, "FW request failed\n");
+			goto release_firmware;
+		}
+
+		ret = adsd3100_g_sensor_firmware(sd);
+		if (ret < 0) {
+			dev_err(adsd3100->dev, "FW parsing failed\n");
+			goto release_firmware;
+		}
+
+		/* Writes for Default firmware */
+		regmap_multi_reg_write(adsd3100->regmap, adsd3100->fw_regs,
+					     adsd3100->fw_regs_count);
+	}
+
+	if (calib_load) {
+		/* Writes for Default calibration */
+		regmap_multi_reg_write(adsd3100->regmap,
+				       adsd3100_powerup_setting,
+				       ARRAY_SIZE(adsd3100_powerup_setting));
+	}
+
+release_firmware:
+	release_firmware(adsd3100->fw);
+	return ret;
+}
+
+static int adsd3100_probe(struct spi_device *client)
+{
+	struct v4l2_fwnode_endpoint bus_cfg = {
+		.bus_type = V4L2_MBUS_CSI2_DPHY
+	};
+	struct device *dev = &client->dev;
+	struct fwnode_handle *endpoint;
+	struct adsd3100 *adsd3100;
+	struct pwm_state state;
+	int ret;
+
+	adsd3100 = devm_kzalloc(dev, sizeof(struct adsd3100), GFP_KERNEL);
+	if (!adsd3100)
+		return -ENOMEM;
+
+	adsd3100->dev = dev;
+
+	adsd3100->regmap = devm_regmap_init(dev, &adsd3100_spi_bus_config, dev,
+					    &adsd3100_spi_regmap_config);
+	if (IS_ERR(adsd3100->regmap)) {
+		dev_err(dev, "Error initializing spi regmap\n");
+		return PTR_ERR(adsd3100->regmap);
+	}
+
+	mutex_init(&adsd3100->lock);
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_parse(endpoint, &bus_cfg);
+	fwnode_handle_put(endpoint);
+	if (ret < 0) {
+		dev_err(dev, "parsing endpoint node failed\n");
+		return ret;
+	}
+
+	adsd3100->rst_gpio = gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(adsd3100->rst_gpio)) {
+		dev_err(dev, "Unable to get \"reset\" gpio\n");
+		return PTR_ERR(adsd3100->rst_gpio);
+	}
+
+	adsd3100->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(adsd3100->pinctrl)) {
+		dev_err(dev, "Unable to get \"pinctrl\" block\n");
+		return PTR_ERR(adsd3100->pinctrl);
+	}
+
+	adsd3100->pins_spi = pinctrl_lookup_state(adsd3100->pinctrl, "spi");
+	if (IS_ERR(adsd3100->pins_spi)) {
+		dev_err(dev, "Unable to get \"spi-pinctrl\" block\n");
+		return PTR_ERR(adsd3100->pins_spi);
+	}
+
+	adsd3100->pins_gpio = pinctrl_lookup_state(adsd3100->pinctrl, "gpio");
+	if (IS_ERR(adsd3100->pins_gpio)) {
+		dev_err(dev, "Unable to get \"gpio-pinctrl\" block\n");
+		return PTR_ERR(adsd3100->pins_gpio);
+	}
+
+	ret = adsd3100_spi_bus_init(&adsd3100->sd);
+	if (ret) {
+		dev_err(dev, "%s: SPI bus initialization failed %d\n",
+			__func__, ret);
+		goto release_gpio;
+	}
+
+	adsd3100->pwm_fsync = devm_pwm_get(dev, NULL);
+	if (IS_ERR(adsd3100->pwm_fsync)) {
+		dev_err(dev, "Failed to get pwm device\n");
+		return PTR_ERR(adsd3100->pwm_fsync);
+	}
+
+	/* Get PWM state. */
+	pwm_init_state(adsd3100->pwm_fsync, &state);
+	pwm_set_relative_duty_cycle(&state, 50, 100);
+	ret = pwm_apply_state(adsd3100->pwm_fsync, &state);
+	if (ret) {
+		dev_err(dev, "%s: PWM init failed %d\n",
+			__func__, ret);
+		goto release_gpio;
+	}
+
+	v4l2_ctrl_handler_init(&adsd3100->ctrls, 3);
+
+	adsd3100->pixel_rate = v4l2_ctrl_new_std(&adsd3100->ctrls,
+						  &adsd3100_ctrl_ops,
+						  V4L2_CID_PIXEL_RATE,
+						  1, INT_MAX, 1, 1);
+	adsd3100->link_freq = v4l2_ctrl_new_int_menu(&adsd3100->ctrls,
+						     &adsd3100_ctrl_ops,
+						     V4L2_CID_LINK_FREQ,
+						     ARRAY_SIZE(
+							     link_freq_tbl) - 1,
+						     0, link_freq_tbl);
+	if (adsd3100->link_freq)
+		adsd3100->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	adsd3100->operating_mode = v4l2_ctrl_new_custom(&adsd3100->ctrls,
+						&adsd3100_ctrl_operating_mode,
+						NULL);
+
+	adsd3100->set_chip_config = v4l2_ctrl_new_custom(&adsd3100->ctrls,
+						&adsd3100_ctrl_chip_config,
+						NULL);
+
+	ret = adsd3100->ctrls.error;
+	if (ret) {
+		dev_err(dev, "%s: control initialization error %d\n",
+			__func__, ret);
+		goto free_ctrl;
+	}
+	adsd3100->sd.ctrl_handler = &adsd3100->ctrls;
+
+	v4l2_spi_subdev_init(&adsd3100->sd, client, &adsd3100_subdev_ops);
+	adsd3100->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	adsd3100->pad.flags = MEDIA_PAD_FL_SOURCE;
+	adsd3100->sd.dev = &client->dev;
+	adsd3100->sd.entity.ops = &adsd3100_subdev_entity_ops;
+	adsd3100->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+
+	ret = media_entity_pads_init(&adsd3100->sd.entity, 1, &adsd3100->pad);
+	if (ret < 0) {
+		dev_err(dev, "could not register media entity\n");
+		goto free_ctrl;
+	}
+
+	ret = adsd3100_firmware_load(&adsd3100->sd);
+	if (ret < 0)
+		return ret;
+
+	adsd3100_entity_init_cfg(&adsd3100->sd, NULL);
+
+	ret = v4l2_async_register_subdev(&adsd3100->sd);
+	if (ret < 0) {
+		dev_err(dev, "could not register v4l2 device\n");
+		goto free_entity;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+free_entity:
+	media_entity_cleanup(&adsd3100->sd.entity);
+free_ctrl:
+	v4l2_ctrl_handler_free(&adsd3100->ctrls);
+	mutex_destroy(&adsd3100->lock);
+release_gpio:
+	gpiod_put(adsd3100->rst_gpio);
+
+	return ret;
+}
+
+static int adsd3100_remove(struct spi_device *client)
+{
+	struct v4l2_subdev *sd = spi_get_drvdata(client);
+	struct adsd3100 *adsd3100 = to_adsd3100(sd);
+
+	v4l2_async_unregister_subdev(&adsd3100->sd);
+	media_entity_cleanup(&adsd3100->sd.entity);
+	gpiod_put(adsd3100->rst_gpio);
+	v4l2_ctrl_handler_free(&adsd3100->ctrls);
+	mutex_destroy(&adsd3100->lock);
+
+	pm_runtime_disable(adsd3100->dev);
+	if (!pm_runtime_status_suspended(adsd3100->dev))
+		adsd3100_power_off(adsd3100->dev);
+	pm_runtime_set_suspended(adsd3100->dev);
+
+	return 0;
+}
+
+static const struct of_device_id adsd3100_of_match[] = {
+	{ .compatible = "adi,adsd3100" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, adsd3100_of_match);
+
+static const struct spi_device_id adsd3100_ids[] = {
+	{ "adsd3100", 0 },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(spi, adsd3100_ids);
+
+static struct spi_driver adsd3100_spi_driver = {
+	.driver			= {
+		.of_match_table = adsd3100_of_match,
+		.name		= "adsd3100",
+		.pm		= &adsd3100_pm_ops,
+	},
+	.probe			= adsd3100_probe,
+	.remove			= adsd3100_remove,
+	.id_table		= adsd3100_ids,
+};
+
+module_spi_driver(adsd3100_spi_driver);
+
+MODULE_DESCRIPTION("Analog Devices ADSD3100 Camera Driver");
+MODULE_AUTHOR("Bogdan Togorean");
+MODULE_LICENSE("GPL v2");
-- 
2.17.1

