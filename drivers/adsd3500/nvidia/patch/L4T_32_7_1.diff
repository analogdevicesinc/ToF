diff --git a/hardware/nvidia/platform/t19x/common/kernel-dts/t19x-common-modules/tegra194-camera-adsd3500-a00.dtsi b/hardware/nvidia/platform/t19x/common/kernel-dts/t19x-common-modules/tegra194-camera-adsd3500-a00.dtsi
new file mode 100644
index 000000000000..cb9015a0b718
--- /dev/null
+++ b/hardware/nvidia/platform/t19x/common/kernel-dts/t19x-common-modules/tegra194-camera-adsd3500-a00.dtsi
@@ -0,0 +1,556 @@
+/*
+ * Copyright (c) 2016-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/ {
+	host1x {
+		vi@15c10000 {
+			num-channels = <1>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				port@0 {
+					reg = <0>;
+					adsd3500_vi_in0: endpoint {
+						port-index = <0>;
+						bus-width = <1>;
+						remote-endpoint = <&adsd3500_csi_out0>;
+					};
+				};
+			};
+		};
+
+		nvcsi@15a00000 {
+			num-channels = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			channel@0 {
+				reg = <0>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						adsd3500_csi_in0: endpoint@0 {
+							port-index = <0>;
+							bus-width = <1>;
+							remote-endpoint = <&adsd3500_out0>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						adsd3500_csi_out0: endpoint@1 {
+							remote-endpoint = <&adsd3500_vi_in0>;
+						};
+					};
+				};
+			};
+		};
+	};
+};
+
+&cam_i2c {
+	gpio_exp_1: gpio@58 {
+            compatible = "maxim,max7320";
+            reg = <0x58>;
+            gpio-controller;
+            #gpio-cells = <2>;
+            gpio-line-names = "M0", "M1", "SI0", "U0",
+                              "IDSEL", "DS2", "EN_1P8", "EN_0P8";
+    	};
+
+	gpio_exp_2: gpio@68 {
+            compatible = "maxim,max7321";
+            reg = <0x68>;
+            gpio-controller;
+            #gpio-cells = <2>;
+            gpio-line-names = "OC0", "OC1", "OC2", "OC3",
+                               "OC4", "OC5", "OC6", "FLASH_WP";
+    	};
+
+	adsd3500@38 {
+		compatible = "adi,adsd3500";
+
+		reg = <0x38>;
+		devnode = "video0";
+
+		/* Physical dimensions of sensor */
+		physical_w = "15.0";
+		physical_h = "12.5";
+
+		sensor_model ="adsd3500";
+		/* Define any required hw resources needed by driver */
+		/* ie. clocks, io pins, power sources */
+
+		/* Defines number of frames to be dropped by driver internally after applying */
+		/* sensor crop settings. Some sensors send corrupt frames after applying */
+		/* crop co-ordinates */
+		post_crop_frame_drop = "0";
+
+		/**
+		* A modeX node is required to support v4l2 driver
+		* implementation with NVIDIA camera software stack
+		*
+		* mclk_khz = "";
+		* Standard MIPI driving clock, typically 24MHz
+		*
+		* num_lanes = "";
+		* Number of lane channels sensor is programmed to output
+		*
+		* tegra_sinterface = "";
+		* The base tegra serial interface lanes are connected to
+		*
+		* discontinuous_clk = "";
+		* The sensor is programmed to use a discontinuous clock on MIPI lanes
+		*
+		* dpcm_enable = "true";
+		* The sensor is programmed to use a DPCM modes
+		*
+		* cil_settletime = "";
+		* MIPI lane settle time value.
+		* A "0" value attempts to autocalibrate based on mclk_multiplier
+		*
+		* active_w = "";
+		* Pixel active region width
+		*
+		* active_h = "";
+		* Pixel active region height
+		*
+		* dynamic_pixel_bit_depth = "";
+		* sensor dynamic bit depth for sensor mode
+		*
+		* csi_pixel_bit_depth = "";
+		* sensor output bit depth for sensor mode
+		*
+		* mode_type="";
+		* Sensor mode type, For eg: yuv, Rgb, bayer, bayer_wdr_pwl
+		*
+		* pixel_phase="";
+		* Pixel phase for sensor mode, For eg: rggb, vyuy, rgb888
+		*
+		* readout_orientation = "0";
+		* Based on camera module orientation.
+		* Only change readout_orientation if you specifically
+		* Program a different readout order for this mode
+		*
+		* line_length = "";
+		* Pixel line length (width) for sensor mode.
+		* This is used to calibrate features in our camera stack.
+		*
+		* mclk_multiplier = "";
+		* Multiplier to MCLK to help time hardware capture sequence
+		* TODO: Assign to PLL_Multiplier as well until fixed in core
+		*
+		* pix_clk_hz = "";
+		* Sensor pixel clock used for calculations like exposure and framerate
+		*
+		*
+		*
+		*
+		* inherent_gain = "";
+		* Gain obtained inherently from mode (ie. pixel binning)
+		*
+		* min_gain_val = ""; (floor to 6 decimal places)
+		* max_gain_val = ""; (floor to 6 decimal places)
+		* gain_step_pitch = ""; (floor to 6 decimal places, unit is db)
+		* Gain limits for mode
+		* if use_decibel_gain = "true", please set the gain as decibel
+		*
+		* min_exp_time = ""; (ceil to integer)
+		* max_exp_time = ""; (ceil to integer)
+		* Exposure Time limits for mode (us)
+		*
+		*
+		* min_hdr_ratio = "";
+		* max_hdr_ratio = "";
+		* HDR Ratio limits for mode
+		*
+		* min_framerate = "";
+		* max_framerate = "";
+		* Framerate limits for mode (fps)
+		*
+		* embedded_metadata_height = "";
+		* Sensor embedded metadata height in units of rows.
+		* If sensor does not support embedded metadata value should be 0.
+		*/
+
+		mode0 {
+			mclk_khz = "31250";
+			num_lanes = "1";
+			tegra_sinterface = "serial_a";
+			phy_mode = "DPHY";
+			discontinuous_clk = "no";
+			dpcm_enable = "false";
+			cil_settletime = "0";
+			dynamic_pixel_bit_depth = "12";
+			csi_pixel_bit_depth = "12";
+			mode_type = "bayer";
+			pixel_phase = "bggr";
+
+			active_w = "512";
+			active_h = "512";
+			readout_orientation = "0";
+			line_length = "512";
+			inherent_gain = "1";
+			mclk_multiplier = "4";
+			pix_clk_hz = "125000000";
+
+			min_gain_val = "0"; /* dB */
+			max_gain_val = "48"; /* dB */
+			gain_step_pitch = "0.3";
+			min_hdr_ratio = "1";
+			max_hdr_ratio = "1";
+			min_framerate = "1.5";
+			max_framerate = "30";
+			min_exp_time = "30";
+			max_exp_time = "660000";
+			embedded_metadata_height = "1";
+		};
+		mode1 {
+			mclk_khz = "37125";
+			num_lanes = "1";
+			tegra_sinterface = "serial_a";
+			phy_mode = "DPHY";
+			discontinuous_clk = "yes";
+			dpcm_enable = "false";
+			cil_settletime = "0";
+			dynamic_pixel_bit_depth = "8";
+			csi_pixel_bit_depth = "8";
+			mode_type = "bayer";
+			pixel_phase = "bggr";
+
+			active_w = "1024";
+			active_h = "512";
+			readout_orientation = "0";
+			line_length = "1024";
+			inherent_gain = "1";
+			mclk_multiplier = "4";
+			pix_clk_hz = "125000000";
+
+			min_gain_val = "0";
+			max_gain_val = "48";
+			gain_step_pitch = "0.3";
+			min_hdr_ratio = "1";
+			max_hdr_ratio = "1";
+			min_framerate = "1.5";
+			max_framerate = "30";
+			min_exp_time = "30";
+			max_exp_time = "660000";
+			embedded_metadata_height = "1";
+		};
+		mode2 {
+			mclk_khz = "37125";
+			num_lanes = "1";
+			tegra_sinterface = "serial_a";
+			phy_mode = "DPHY";
+			discontinuous_clk = "yes";
+			dpcm_enable = "false";
+			cil_settletime = "0";
+			dynamic_pixel_bit_depth = "8";
+			csi_pixel_bit_depth = "8";
+			mode_type = "bayer";
+			pixel_phase = "bggr";
+
+			active_w = "1280";
+			active_h = "512";
+			readout_orientation = "0";
+			line_length = "1280";
+			inherent_gain = "1";
+			mclk_multiplier = "4";
+			pix_clk_hz = "125000000";
+
+			min_gain_val = "0";
+			max_gain_val = "48";
+			gain_step_pitch = "0.3";
+			min_hdr_ratio = "1";
+			max_hdr_ratio = "1";
+			min_framerate = "1.5";
+			max_framerate = "30";
+			min_exp_time = "30";
+			max_exp_time = "660000";
+			embedded_metadata_height = "1";
+		};
+		mode3 {
+			mclk_khz = "37125";
+			num_lanes = "1";
+			tegra_sinterface = "serial_a";
+			phy_mode = "DPHY";
+			discontinuous_clk = "yes";
+			dpcm_enable = "false";
+			cil_settletime = "0";
+			dynamic_pixel_bit_depth = "8";
+			csi_pixel_bit_depth = "8";
+			mode_type = "bayer";
+			pixel_phase = "bggr";
+
+			active_w = "1536";
+			active_h = "512";
+			readout_orientation = "0";
+			line_length = "1536";
+			inherent_gain = "1";
+			mclk_multiplier = "4";
+			pix_clk_hz = "125000000";
+
+			min_gain_val = "0";
+			max_gain_val = "48";
+			gain_step_pitch = "0.3";
+			min_hdr_ratio = "1";
+			max_hdr_ratio = "1";
+			min_framerate = "1.5";
+			max_framerate = "30";
+			min_exp_time = "30";
+			max_exp_time = "660000";
+			embedded_metadata_height = "1";
+		};
+		mode4 {
+			mclk_khz = "37125";
+			num_lanes = "1";
+			tegra_sinterface = "serial_a";
+			phy_mode = "DPHY";
+			discontinuous_clk = "yes";
+			dpcm_enable = "false";
+			cil_settletime = "0";
+			dynamic_pixel_bit_depth = "8";
+			csi_pixel_bit_depth = "8";
+			mode_type = "bayer";
+			pixel_phase = "bggr";
+
+			active_w = "1792";
+			active_h = "512";
+			readout_orientation = "0";
+			line_length = "1792";
+			inherent_gain = "1";
+			mclk_multiplier = "4";
+			pix_clk_hz = "125000000";
+
+			min_gain_val = "0";
+			max_gain_val = "48";
+			gain_step_pitch = "0.3";
+			min_hdr_ratio = "1";
+			max_hdr_ratio = "1";
+			min_framerate = "1.5";
+			max_framerate = "30";
+			min_exp_time = "30";
+			max_exp_time = "660000";
+			embedded_metadata_height = "1";
+		};
+		mode5 {
+			mclk_khz = "37125";
+			num_lanes = "1";
+			tegra_sinterface = "serial_a";
+			phy_mode = "DPHY";
+			discontinuous_clk = "yes";
+			dpcm_enable = "false";
+			cil_settletime = "0";
+			dynamic_pixel_bit_depth = "8";
+			csi_pixel_bit_depth = "8";
+			mode_type = "bayer";
+			pixel_phase = "bggr";
+
+			active_w = "2048";
+			active_h = "512";
+			readout_orientation = "0";
+			line_length = "2048";
+			inherent_gain = "1";
+			mclk_multiplier = "4";
+			pix_clk_hz = "125000000";
+
+			min_gain_val = "0";
+			max_gain_val = "48";
+			gain_step_pitch = "0.3";
+			min_hdr_ratio = "1";
+			max_hdr_ratio = "1";
+			min_framerate = "1.5";
+			max_framerate = "30";
+			min_exp_time = "30";
+			max_exp_time = "660000";
+			embedded_metadata_height = "1";
+		};
+		mode6 {
+			mclk_khz = "37125";
+			num_lanes = "1";
+			tegra_sinterface = "serial_a";
+			phy_mode = "DPHY";
+			discontinuous_clk = "yes";
+			dpcm_enable = "false";
+			cil_settletime = "0";
+			dynamic_pixel_bit_depth = "8";
+			csi_pixel_bit_depth = "8";
+			mode_type = "bayer";
+			pixel_phase = "bggr";
+
+			active_w = "2304";
+			active_h = "512";
+			readout_orientation = "0";
+			line_length = "2304";
+			inherent_gain = "1";
+			mclk_multiplier = "4";
+			pix_clk_hz = "125000000";
+
+			min_gain_val = "0";
+			max_gain_val = "48";
+			gain_step_pitch = "0.3";
+			min_hdr_ratio = "1";
+			max_hdr_ratio = "1";
+			min_framerate = "1.5";
+			max_framerate = "30";
+			min_exp_time = "30";
+			max_exp_time = "660000";
+			embedded_metadata_height = "1";
+		};
+		mode7 {
+			mclk_khz = "37125";
+			num_lanes = "1";
+			tegra_sinterface = "serial_a";
+			phy_mode = "DPHY";
+			discontinuous_clk = "yes";
+			dpcm_enable = "false";
+			cil_settletime = "0";
+			dynamic_pixel_bit_depth = "8";
+			csi_pixel_bit_depth = "8";
+			mode_type = "bayer";
+			pixel_phase = "bggr";
+
+			active_w = "2650";
+			active_h = "512";
+			readout_orientation = "0";
+			line_length = "2560";
+			inherent_gain = "1";
+			mclk_multiplier = "4";
+			pix_clk_hz = "125000000";
+
+			min_gain_val = "0";
+			max_gain_val = "48";
+			gain_step_pitch = "0.3";
+			min_hdr_ratio = "1";
+			max_hdr_ratio = "1";
+			min_framerate = "1.5";
+			max_framerate = "30";
+			min_exp_time = "30";
+			max_exp_time = "660000";
+			embedded_metadata_height = "1";
+		};
+		mode8 {
+			mclk_khz = "37125";
+			num_lanes = "1";
+			tegra_sinterface = "serial_a";
+			phy_mode = "DPHY";
+			discontinuous_clk = "yes";
+			dpcm_enable = "false";
+			cil_settletime = "0";
+			dynamic_pixel_bit_depth = "12";
+			csi_pixel_bit_depth = "12";
+			mode_type = "bayer";
+			pixel_phase = "bggr";
+
+			active_w = "3072";
+			active_h = "1024";
+			readout_orientation = "0";
+			line_length = "3072";
+			inherent_gain = "1";
+			mclk_multiplier = "4";
+			pix_clk_hz = "125000000";
+
+			min_gain_val = "0";
+			max_gain_val = "48";
+			gain_step_pitch = "0.3";
+			min_hdr_ratio = "1";
+			max_hdr_ratio = "1";
+			min_framerate = "1.5";
+			max_framerate = "30";
+			min_exp_time = "30";
+			max_exp_time = "660000";
+			embedded_metadata_height = "1";
+		};
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+				adsd3500_out0: endpoint {
+					port-index = <0>;
+					bus-width = <1>;
+					remote-endpoint = <&adsd3500_csi_in0>;
+				};
+			};
+		};
+	};
+};
+
+/ {
+
+	tegra-camera-platform {
+		compatible = "nvidia, tegra-camera-platform";
+		/**
+		* Physical settings to calculate max ISO BW
+		*
+		* num_csi_lanes = <>;
+		* Total number of CSI lanes when all cameras are active
+		*
+		* max_lane_speed = <>;
+		* Max lane speed in Kbit/s
+		*
+		* min_bits_per_pixel = <>;
+		* Min bits per pixel
+		*
+		* vi_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the VI ISO case
+		*
+		* vi_bw_margin_pct = <>;
+		* Vi bandwidth margin in percentage
+		*
+		* max_pixel_rate = <>;
+		* Max pixel rate in Kpixel/s for the ISP ISO case
+		*
+		* isp_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the ISP ISO case
+		*
+		* isp_bw_margin_pct = <>;
+		* Isp bandwidth margin in percentage
+		*/
+		num_csi_lanes = <1>;
+		max_lane_speed = <2500000>;
+		min_bits_per_pixel = <8>;
+		vi_peak_byte_per_pixel = <5>;
+		vi_bw_margin_pct = <25>;
+		isp_peak_byte_per_pixel = <5>;
+		isp_bw_margin_pct = <25>;
+
+		/**
+		 * The general guideline for naming badge_info contains 3 parts, and is as follows,
+		 * The first part is the camera_board_id for the module; if the module is in a FFD
+		 * platform, then use the platform name for this part.
+		 * The second part contains the position of the module, ex. "rear" or "front".
+		 * The third part contains the last 6 characters of a part number which is found
+		 * in the module's specsheet from the vender.
+		 */
+		modules {
+			module0 {
+				badge = "adi_adsd3500_bottom";
+				position = "bottom";
+				orientation = "0";
+				drivernode0 {
+					/* Declare PCL support driver (classically known as guid)  */
+					pcl_id = "v4l2_sensor";
+					/* Driver v4l2 device name */
+					devname = "adsd3500 2-0038";
+					/* Declare the device-tree hierarchy to driver instance */
+					proc-device-tree = "/proc/device-tree/i2c@3180000/adsd3500@38";
+				};
+			};
+		};
+	};
+};
diff --git a/hardware/nvidia/platform/t19x/galen/kernel-dts/tegra194-p2888-0001-p2822-0000.dts b/hardware/nvidia/platform/t19x/galen/kernel-dts/tegra194-p2888-0001-p2822-0000.dts
index f4073dbc2f6e..79af899ddd36 100644
--- a/hardware/nvidia/platform/t19x/galen/kernel-dts/tegra194-p2888-0001-p2822-0000.dts
+++ b/hardware/nvidia/platform/t19x/galen/kernel-dts/tegra194-p2888-0001-p2822-0000.dts
@@ -13,5 +13,4 @@
  * more details.
  */
 #include "common/tegra194-p2888-0001-p2822-0000-common.dtsi"
-#include "common/tegra194-p2822-camera-modules.dtsi"
-#include "t19x-common-modules/tegra194-camera-plugin-manager.dtsi"
+#include "t19x-common-modules/tegra194-camera-adsd3500-a00.dtsi"
diff --git a/kernel/kernel-4.9/arch/arm64/configs/tegra_defconfig b/kernel/kernel-4.9/arch/arm64/configs/tegra_defconfig
index 3d344469e2b4..3d06a0848459 100644
--- a/kernel/kernel-4.9/arch/arm64/configs/tegra_defconfig
+++ b/kernel/kernel-4.9/arch/arm64/configs/tegra_defconfig
@@ -671,6 +671,7 @@ CONFIG_PINCTRL_TEGRA194_PEXCLK_PADCTL=y
 CONFIG_GPIO_PCA953X=y
 CONFIG_GPIO_PCA953X_IRQ=y
 CONFIG_GPIO_MAX77620=y
+CONFIG_GPIO_MAX732X=y
 CONFIG_GPIO_TMPM32X_I2C=y
 CONFIG_PADCTRL=y
 CONFIG_PADCTRL_GENERIC_TEGRA_IO_PAD=y
@@ -777,6 +778,7 @@ CONFIG_VIDEO_VIVID=m
 CONFIG_VIDEO_CAMERA=y
 CONFIG_VIDEO_TEGRA_VIVID=m
 # CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+CONFIG_VIDEO_ADSD3500=m
 CONFIG_VIDEO_IMX185=m
 CONFIG_VIDEO_IMX219=y
 CONFIG_VIDEO_IMX477=y
diff --git a/kernel/kernel-4.9/include/uapi/linux/v4l2-controls.h b/kernel/kernel-4.9/include/uapi/linux/v4l2-controls.h
index b6a357a5f053..2e4ddb8d510c 100644
--- a/kernel/kernel-4.9/include/uapi/linux/v4l2-controls.h
+++ b/kernel/kernel-4.9/include/uapi/linux/v4l2-controls.h
@@ -180,6 +180,11 @@ enum v4l2_colorfx {
  * We reserve 16 controls for this driver. */
 #define V4L2_CID_USER_TC358743_BASE		(V4L2_CID_USER_BASE + 0x1080)
 
+/* The base for the addicmos driver controls.
+* We reserve 16 controls for this driver.
+*/
+#define V4L2_CID_USER_ADITOF_BASE		(V4L2_CID_USER_BASE + 0x10e0)
+
 /* MPEG-class control IDs */
 /* The MPEG controls are applicable to all codec controls
  * and the 'MPEG' part of the define is historical */
diff --git a/kernel/nvidia/drivers/media/i2c/Kconfig b/kernel/nvidia/drivers/media/i2c/Kconfig
index 326dbb096017..336c68d32b52 100644
--- a/kernel/nvidia/drivers/media/i2c/Kconfig
+++ b/kernel/nvidia/drivers/media/i2c/Kconfig
@@ -3,6 +3,16 @@ if VIDEO_V4L2
 menu "NVIDIA overlay Encoders, decoders, sensors and other helper chips"
 	visible if !MEDIA_SUBDRV_AUTOSELECT || COMPILE_TEST
 
+config VIDEO_ADSD3500
+	tristate "Analog Devices ADSD3500 driver"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API && REGMAP_I2C
+	---help---
+	This is a Video4Linux2 sensor-level driver for 
+	Analog Devices ADSD3500 ISP Chip
+
+	To compile this driver as a module, choose M here: the
+	module will be called adsd3500.
+
 config VIDEO_IMX185
 	tristate "IMX185 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/kernel/nvidia/drivers/media/i2c/Makefile b/kernel/nvidia/drivers/media/i2c/Makefile
index c6d34e8077e3..f24640103eed 100644
--- a/kernel/nvidia/drivers/media/i2c/Makefile
+++ b/kernel/nvidia/drivers/media/i2c/Makefile
@@ -3,6 +3,7 @@ subdir-ccflags-y += -Werror
 ccflags-y += -I$(srctree)/drivers/media/platform/tegra
 ccflags-y += -I$(srctree)/drivers/video/tegra/camera
 
+obj-$(CONFIG_VIDEO_ADSD3500) += adsd3500.o
 obj-$(CONFIG_VIDEO_IMX185) += imx185.o
 obj-$(CONFIG_VIDEO_IMX185) += imx185_v1.o
 obj-$(CONFIG_VIDEO_IMX477) += imx477.o
diff --git a/kernel/nvidia/drivers/media/i2c/adsd3500.c b/kernel/nvidia/drivers/media/i2c/adsd3500.c
new file mode 100644
index 000000000000..d20657ae73f8
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/adsd3500.c
@@ -0,0 +1,911 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for the Analog Devices ADSD3500 chip.
+ *
+ * Copyright (C) 2022 Analog Devices, All Rights Reserved.
+ *
+ */
+
+#include "adsd3500_regs.h"
+
+#include <linux/bitfield.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pwm.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-of.h>
+#include <media/v4l2-subdev.h>
+
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+
+#include "adsd3500_mode_tbls.h"
+
+#define ADSD3500_DEFAULT_MODE		ADSD3500_MODE_512x512_30FPS
+#define ADSD3500_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SBGGR12_1X12
+#define ADSD3500_DEFAULT_WIDTH		512
+#define ADSD3500_DEFAULT_HEIGHT		512
+
+struct adsd3500_mode_info {
+	uint32_t width;
+	uint32_t height;
+	uint32_t pixel_rate;
+	uint32_t code;
+	uint32_t link_freq_idx;
+};
+
+struct adsd3500_config_info {
+	uint8_t nr_depth_bits;
+	uint8_t nr_ab_bits;
+	uint8_t nr_confidence_bits;
+	uint8_t nr_mipi_lanes;
+	bool use_vc;
+};
+
+struct adsd3500 {
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct device *dev;
+	struct v4l2_subdev *sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt fmt;
+	struct v4l2_rect crop;
+
+	const struct adsd3500_mode_info *current_mode;
+	struct adsd3500_config_info current_config;
+
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+
+	struct v4l2_ctrl_handler 	ctrl_handler;
+
+	struct mutex lock;
+	bool streaming;
+
+	struct v4l2_ctrl *ctrls[];
+};
+
+#define V4L2_CID_ADSD3500_OPERATING_MODE  (V4L2_CID_USER_ADITOF_BASE + 0)
+#define V4L2_CID_ADSD3500_CHIP_CONFIG (V4L2_CID_USER_ADITOF_BASE + 1)
+#define V4L2_CID_ADSD3500_DEPTH_BITS (V4L2_CID_USER_ADITOF_BASE + 2)
+#define V4L2_CID_ADSD3500_AB_BITS (V4L2_CID_USER_ADITOF_BASE + 3)
+#define V4L2_CID_ADSD3500_CONFIDENCE_BITS (V4L2_CID_USER_ADITOF_BASE + 4)
+#define V4L2_CID_ADSD3500_AB_AVG (V4L2_CID_USER_ADITOF_BASE + 5)
+#define V4L2_CID_ADSD3500_DEPTH_EN (V4L2_CID_USER_ADITOF_BASE + 6)
+
+static const struct reg_sequence adsd3500_powerup_setting[] = {
+};
+
+static const struct reg_sequence adsd3500_powerdown_setting[] = {
+};
+
+static const struct reg_sequence adsd3500_standby_setting[] = {
+};
+
+static const s64 link_freq_tbl[] = {
+	732000000,
+	732000000,
+	732000000,
+	732000000,
+	732000000,
+	732000000,
+	732000000,
+	732000000,
+	732000000,
+};
+
+/* Elements of the structure must be ordered ascending by width & height */
+static const struct adsd3500_mode_info adsd3500_mode_info_data[] = {
+	{ //RAW12 12BPP
+		.width = 512,
+		.height = 512,
+		.pixel_rate = 488000000,
+		.code = MEDIA_BUS_FMT_SBGGR12_1X12,
+		.link_freq_idx = 0 /* an index in link_freq_tbl[] */
+	},
+	{ //RAW8 16BPP
+		.width = 1024,
+		.height = 512,
+		.pixel_rate = 488000000,
+		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.link_freq_idx = 1 /* an index in link_freq_tbl[] */
+	},
+	{ //RAW8 20BPP
+		.width = 1280,
+		.height = 512,
+		.pixel_rate = 488000000,
+		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.link_freq_idx = 2 /* an index in link_freq_tbl[] */
+	},
+	{ //RAW8 24BPP
+		.width = 1536,
+		.height = 512,
+		.pixel_rate = 488000000,
+		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.link_freq_idx = 3 /* an index in link_freq_tbl[] */
+	},
+	{ //RAW8 28BPP
+		.width = 1792,
+		.height = 512,
+		.pixel_rate = 488000000,
+		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.link_freq_idx = 4 /* an index in link_freq_tbl[] */
+	},
+	{ //RAW8 32BPP
+		.width = 2048,
+		.height = 512,
+		.pixel_rate = 488000000,
+		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.link_freq_idx = 5 /* an index in link_freq_tbl[] */
+	},
+	{ //RAW8 36BPP
+		.width = 2304,
+		.height = 512,
+		.pixel_rate = 488000000,
+		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.link_freq_idx = 6 /* an index in link_freq_tbl[] */
+	},
+	{ //RAW8 40BPP
+		.width = 2560,
+		.height = 512,
+		.pixel_rate = 488000000,
+		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.link_freq_idx = 7 /* an index in link_freq_tbl[] */
+	},
+	{ //RAW12 12BPP * 3 phase
+		.width = 3072,
+		.height = 1024,
+		.pixel_rate = 488000000,
+		.code = MEDIA_BUS_FMT_SBGGR12_1X12,
+		.link_freq_idx = 8 /* an index in link_freq_tbl[] */
+	}
+};
+
+static bool adsd3500_regmap_accessible_reg(struct device *dev, unsigned int reg)
+{
+	if (reg % 2)
+		return 0;
+
+	switch (reg) {
+		case GET_CHIP_ID_CMD:
+		case GET_IMAGER_MODE_CMD:
+		case GET_IMAGER_AB_INVLD_TRSHLD:
+		case GET_IMAGER_CONFIDENCE_TRSHLD:
+		case GET_IMAGER_JBLF_STATE:
+		case GET_IMAGER_JBLF_FILT_SIZE:
+		case GET_STATUS_CMD:
+			return 1;
+		default:
+			return 0;
+	}
+}
+
+static const struct regmap_config adsd3500_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 16,
+	.cache_type = REGCACHE_NONE,
+	.readable_reg = adsd3500_regmap_accessible_reg,
+};
+
+static int adsd3500_power_on(struct camera_common_data *s_data)
+{
+	struct adsd3500 *adsd3500 = (struct adsd3500 *)s_data->priv;
+	struct v4l2_ctrl *operating_mode = adsd3500->ctrls[1];
+	struct v4l2_ctrl *ab_avg = adsd3500->ctrls[2];
+	struct v4l2_ctrl *depth_en = adsd3500->ctrls[3];
+	struct adsd3500_config_info config = adsd3500->current_config;
+	unsigned int write_cmd, write_val = 0;
+	int ret;
+	
+	dev_dbg(adsd3500->dev, "Entered addicmos_power_on\n");
+	
+	write_cmd = SET_IMAGER_MODE_CMD | SET_IMAGER_MODE(operating_mode->val);
+
+	write_val |= SET_IMAGER_MODE_DEPTH_EN(depth_en->val);
+	write_val |= SET_IMAGER_MODE_DEPTH_BITS(config.nr_depth_bits ? 6 - config.nr_depth_bits: 0);
+	
+	write_val |= SET_IMAGER_MODE_AB_EN(config.nr_ab_bits ? 1 : 0);
+	write_val |= SET_IMAGER_MODE_AB_BITS(config.nr_ab_bits ? 6 - config.nr_ab_bits : 0);
+
+	write_val |= SET_IMAGER_MODE_CONF_BITS(config.nr_confidence_bits);
+
+	write_val |= SET_IMAGER_MODE_VC_EN(!config.use_vc);
+	write_val |= SET_IMAGER_MODE_AB_AVG_EN(ab_avg->val);
+	write_val |= SET_IMAGER_MODE_MIPI_LANES_NR(config.nr_mipi_lanes);
+
+	ret = regmap_write(adsd3500->regmap, write_cmd, write_val);
+	if (ret) {
+		dev_err(adsd3500->dev, "Could not set mode register\n");
+		return ret;
+	}
+	
+	return 0;
+}
+
+static int adsd3500_power_off(struct camera_common_data *s_data)
+{
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int adsd3500_g_register(struct v4l2_subdev *sd,
+			       struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct adsd3500 *adsd3500 = (struct adsd3500 *)s_data->priv;
+	unsigned int read_val;
+	int ret;
+
+	reg->size = 2;
+	ret = regmap_read(adsd3500->regmap, reg->reg, &read_val);
+	reg->val = read_val;
+
+	return ret;
+}
+
+static int adsd3500_s_register(struct v4l2_subdev *sd,
+			       const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct adsd3500 *adsd3500 = (struct adsd3500 *)s_data->priv;
+
+	return regmap_write(adsd3500->regmap, reg->reg, reg->val);
+}
+#endif
+
+static int adsd3500_bpp_config(struct adsd3500 *priv,
+				    struct v4l2_ctrl *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_ADSD3500_DEPTH_BITS:
+		priv->current_config.nr_depth_bits = ctrl->val;
+		break;
+	case V4L2_CID_ADSD3500_AB_BITS:
+		priv->current_config.nr_ab_bits = ctrl->val;
+		break;
+	case V4L2_CID_ADSD3500_CONFIDENCE_BITS:
+		priv->current_config.nr_confidence_bits = ctrl->val;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int adsd3500_chip_config(struct adsd3500 *adsd3500,
+				    struct v4l2_ctrl *ctrl)
+{
+	struct device *dev = adsd3500->dev;
+	struct i2c_client *client = adsd3500->i2c_client;
+	uint16_t pld_size;
+	uint8_t r_w, *data;
+	int ret;
+
+	r_w = *ctrl->p_new.p_u8;
+	pld_size = (uint16_t)(*(ctrl->p_new.p_u8 + 1) << 8 | *(ctrl->p_new.p_u8 + 2));
+	data = ctrl->p_new.p_u8 + 3;
+
+	dev_dbg(dev, "Entered adsd3500_chip_config. R/W: %d, PLD_SIZE: %d\n", r_w, pld_size);
+
+	if ((pld_size > 4096) || (pld_size < 2))
+		return -EINVAL;
+
+	if (r_w) {
+		ret = i2c_master_send(client, data, pld_size);
+		if (ret < 0) {
+			dev_warn(dev, "Write burst transfer failed\n");
+			return -EIO;
+		}
+	} else {
+		ret = i2c_master_recv(client, data, pld_size);
+		if (ret < 0) {
+			dev_warn(dev, "Read burst transfer failed\n");
+			return -EIO;
+		}
+	}
+	memset(ctrl->p_new.p_u8, 0xFF, 1);
+	return 0;
+}
+
+static int adsd3500_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct adsd3500 *priv = container_of(ctrl->handler, struct adsd3500, ctrl_handler);
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	switch (ctrl->id) {
+	default:
+		dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int adsd3500_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct adsd3500 *adsd3500 = container_of(ctrl->handler,
+						 struct adsd3500, ctrl_handler);
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ADSD3500_OPERATING_MODE:
+	case TEGRA_CAMERA_CID_SENSOR_MODE_ID:
+	case V4L2_CID_ADSD3500_AB_AVG:
+	case V4L2_CID_ADSD3500_DEPTH_EN:
+	case V4L2_CID_PIXEL_RATE:
+	case V4L2_CID_LINK_FREQ:
+		break;
+	case V4L2_CID_ADSD3500_CHIP_CONFIG:
+		ret = adsd3500_chip_config(adsd3500, ctrl);
+		break;
+	case V4L2_CID_ADSD3500_DEPTH_BITS:
+	case V4L2_CID_ADSD3500_AB_BITS:
+	case V4L2_CID_ADSD3500_CONFIDENCE_BITS:
+		ret = adsd3500_bpp_config(adsd3500, ctrl);
+		break;
+	default:
+		dev_err(adsd3500->dev, "%s > Unhandled: %x  param=%x\n",
+			__func__, ctrl->id, ctrl->val);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops adsd3500_ctrl_ops = {
+	.g_volatile_ctrl = adsd3500_g_volatile_ctrl,
+	.s_ctrl = adsd3500_s_ctrl,
+};
+
+static const s64 nr_bits_qmenu[] = {
+	0, 4, 8, 10, 12, 14, 16
+};
+
+static const struct v4l2_ctrl_config adsd3500_ctrls[] = {
+	{
+		.ops		= &adsd3500_ctrl_ops,
+		.id		= TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+		.name		= "Sensor Mode",
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.flags		= V4L2_CTRL_FLAG_SLIDER,
+		.min		= 0,
+		.max		= 0xFF,
+		.def		= 0x0,
+		.step 		= 1,
+	},
+	{
+		/* Should always be second control in list*/
+		.ops		= &adsd3500_ctrl_ops,
+		.id		= V4L2_CID_ADSD3500_OPERATING_MODE,
+		.name		= "Operating Mode",
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.def		= 7,
+		.min		= 0,
+		.max		= 10,
+		.step		= 1,
+	},
+	{
+		/* Should always be third control in list*/
+		.ops		= &adsd3500_ctrl_ops,
+		.id		= V4L2_CID_ADSD3500_AB_AVG,
+		.name		= "AB Averaging",
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.def		= 1,
+		.min		= 0,
+		.max		= 1,
+		.step		= 1,
+	},
+	{
+		/* Should always be fourth control in list*/
+		.ops		= &adsd3500_ctrl_ops,
+		.id		= V4L2_CID_ADSD3500_DEPTH_EN,
+		.name		= "Depth enable",
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.def		= 1,
+		.min		= 0,
+		.max		= 1,
+		.step		= 1,
+	},
+	{
+		.ops		= &adsd3500_ctrl_ops,
+		.id		= V4L2_CID_ADSD3500_CHIP_CONFIG,
+		.name		= "Chip Config",
+		.type		= V4L2_CTRL_TYPE_U8,
+		.def		= 0x00,
+		.min		= 0x00,
+		.max		= 0xFF,
+		.step		= 1,
+		.dims		= { 4099 }
+	},
+	{
+		.ops		= &adsd3500_ctrl_ops,
+		.id		= V4L2_CID_ADSD3500_DEPTH_BITS,
+		.name		= "Phase / Depth Bits",
+		.type		= V4L2_CTRL_TYPE_INTEGER_MENU,
+		.def		= 2,
+		.min		= 2,
+		.max		= 6,
+		.menu_skip_mask = 0x03,
+		.qmenu_int	= nr_bits_qmenu,
+	},
+	{
+		.ops		= &adsd3500_ctrl_ops,
+		.id		= V4L2_CID_ADSD3500_AB_BITS,
+		.name		= "AB Bits",
+		.type		= V4L2_CTRL_TYPE_INTEGER_MENU,
+		.def		= 0,
+		.min		= 0,
+		.max		= 6,
+		.menu_skip_mask = 0x02,
+		.qmenu_int	= nr_bits_qmenu,
+	},
+	{
+		.ops		= &adsd3500_ctrl_ops,
+		.id		= V4L2_CID_ADSD3500_CONFIDENCE_BITS,
+		.name		= "Confidence Bits",
+		.type		= V4L2_CTRL_TYPE_INTEGER_MENU,
+		.def		= 0,
+		.min		= 0,
+		.max		= 2,
+		.qmenu_int	= nr_bits_qmenu,
+	}
+};
+
+static int adsd3500_enum_mbus_code(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_pad_config *cfg,
+				   struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad != 0)
+		return -EINVAL;
+
+	switch (code->index) {
+	case 0:
+		code->code = MEDIA_BUS_FMT_SBGGR8_1X8;
+		break;
+	case 1:
+		code->code = MEDIA_BUS_FMT_SBGGR12_1X12;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int adsd3500_enum_frame_size(struct v4l2_subdev *subdev,
+				    struct v4l2_subdev_pad_config *cfg,
+				    struct v4l2_subdev_frame_size_enum *fse)
+{
+	int i, j = 0;
+
+	if (fse->index >= ARRAY_SIZE(adsd3500_mode_info_data))
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(adsd3500_mode_info_data); i++)
+	{
+		if(adsd3500_mode_info_data[i].code == fse->code)
+			j++;
+		if (j > fse->index)
+			break;
+	}
+
+	if (i < ARRAY_SIZE(adsd3500_mode_info_data)) {
+		fse->min_width = adsd3500_mode_info_data[i].width;
+		fse->max_width = adsd3500_mode_info_data[i].width;
+		fse->min_height = adsd3500_mode_info_data[i].height;
+		fse->max_height = adsd3500_mode_info_data[i].height;
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int adsd3500_get_format(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int adsd3500_set_format(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_format *format)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	int ret;
+	
+	dev_dbg(dev, "set_fmt: %x %dx%d %d\n",
+		format->format.code, format->format.width,
+		format->format.height, format->which);
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static int adsd3500_start_streaming(struct adsd3500 *adsd3500)
+{
+	int ret;
+
+	ret = regmap_write(adsd3500->regmap, STREAM_ON_CMD, STREAM_ON_VAL);
+	if (ret < 0)
+		dev_err(adsd3500->dev, "Write of STREAM-ON command failed.\n");
+
+	return ret;
+}
+
+static int adsd3500_stop_streaming(struct adsd3500 *adsd3500)
+{
+	int ret;
+
+	ret = regmap_write(adsd3500->regmap, STREAM_OFF_CMD, STREAM_OFF_VAL);
+	if (ret < 0)
+		dev_err(adsd3500->dev, "Write of STREAM-OFF command failed.\n");
+	
+	return ret;
+}
+
+static int adsd3500_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(subdev);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct adsd3500 *adsd3500 = (struct adsd3500 *)s_data->priv;
+	int ret = 0;
+
+	dev_dbg(dev, "s_stream: %d\n", enable);
+
+	mutex_lock(&adsd3500->lock);
+	if (adsd3500->streaming == enable) {
+		mutex_unlock(&adsd3500->lock);
+		return 0;
+	}
+
+	if (enable) {
+		adsd3500_power_on(s_data);
+		ret = adsd3500_start_streaming(adsd3500);
+		if (ret)
+			goto err_unlock;
+	} else {
+		adsd3500_stop_streaming(adsd3500);
+	}
+
+	adsd3500->streaming = enable;
+	mutex_unlock(&adsd3500->lock);
+
+	return ret;
+	
+err_unlock:
+	mutex_unlock(&adsd3500->lock);
+
+	return ret;
+}
+
+static int adsd3500_g_frame_interval(struct v4l2_subdev *subdev,
+				     struct v4l2_subdev_frame_interval *fi)
+{
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	return 0;
+}
+
+static int adsd3500_s_frame_interval(struct v4l2_subdev *subdev,
+				     struct v4l2_subdev_frame_interval *fi)
+{
+	return 0;
+}
+
+static int adsd3500_link_setup(struct media_entity *entity,
+			   const struct media_pad *local,
+			   const struct media_pad *remote, u32 flags)
+{
+	return 0;
+}
+
+static int adsd3500_ctrls_init(struct adsd3500 *priv)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct v4l2_ctrl *ctrl;
+	int num_ctrls;
+	int err;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	num_ctrls = ARRAY_SIZE(adsd3500_ctrls);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, num_ctrls);
+
+	for (i = 0; i < num_ctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&adsd3500_ctrls[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				adsd3500_ctrls[i].name);
+			continue;
+		}
+
+		if (adsd3500_ctrls[i].type == V4L2_CTRL_TYPE_STRING &&
+			adsd3500_ctrls[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				adsd3500_ctrls[i].max + 1, GFP_KERNEL);
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->sd->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+	
+		//Initialize by default to 4 (RAW12, 12 bpp)
+	v4l2_ctrl_s_ctrl(priv->ctrls[5], 4);
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+static int adsd3500_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops adsd3500_subdev_internal_ops = {
+	.open = adsd3500_open,
+};
+
+const static struct of_device_id adsd3500_of_match[] = {
+	{ .compatible = "adi,adsd3500" },
+	{ /* sentinel */ }
+};
+
+static struct camera_common_pdata *adsd3500_parse_dt(struct i2c_client *client,
+				struct camera_common_data *s_data)
+{
+	struct adsd3500 *adsd3500 = (struct adsd3500 *)s_data->priv;
+	struct device_node *np = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	int err;
+	int gpio;
+	const char *str;
+
+	if (!np)
+		return NULL;
+	
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			sizeof(*board_priv_pdata), GFP_KERNEL);
+
+	adsd3500->current_config.use_vc = of_property_read_bool(np, "adi,use-vc");
+	if (adsd3500->current_config.use_vc)
+		dev_dbg(&client->dev, "Virtual Channel mode activated\n");
+
+	err = of_property_read_string(np, "use_sensor_mode_id", &str);
+	if (!err) {
+		if (!strcmp(str, "true"))
+			s_data->use_sensor_mode_id = true;
+		else
+			s_data->use_sensor_mode_id = false;
+	}
+
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		dev_err(&client->dev, "Reset-gpios not found %d\n", gpio);
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	return board_priv_pdata;
+}
+
+MODULE_DEVICE_TABLE(of, adsd3500_of_match);
+
+static struct camera_common_sensor_ops adsd3500_common_ops = {
+	.power_off = adsd3500_power_off
+};
+
+static const struct v4l2_subdev_core_ops adsd3500_core_ops = {
+	.s_power = camera_common_s_power,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = adsd3500_g_register,
+	.s_register = adsd3500_s_register,
+#endif
+};
+
+static const struct v4l2_subdev_video_ops adsd3500_video_ops = {
+	.s_stream = adsd3500_s_stream,
+	.g_frame_interval = adsd3500_g_frame_interval,
+	.s_frame_interval = adsd3500_s_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops adsd3500_subdev_pad_ops = {
+	.enum_mbus_code = adsd3500_enum_mbus_code,
+	.enum_frame_size = adsd3500_enum_frame_size,
+	.get_fmt = adsd3500_get_format,
+	.set_fmt = adsd3500_set_format,
+};
+
+static const struct v4l2_subdev_ops adsd3500_subdev_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.core = &adsd3500_core_ops,
+#endif
+	.video = &adsd3500_video_ops,
+	.pad = &adsd3500_subdev_pad_ops,
+};
+
+static const struct media_entity_operations adsd3500_subdev_entity_ops = {
+	.link_setup = adsd3500_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int adsd3500_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct adsd3500 *priv;
+	unsigned int read_val;
+	int ret;
+
+	dev_info(&client->dev, "probing adsd3500 v4l2 sensor\n");
+
+	common_data = devm_kzalloc(&client->dev, sizeof(struct camera_common_data),
+							   GFP_KERNEL);
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct adsd3500) + sizeof(struct v4l2_ctrl *) *
+			    ARRAY_SIZE(adsd3500_ctrls),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	common_data->priv = (void *)priv;
+
+	priv->regmap = devm_regmap_init_i2c(client,
+						 &adsd3500_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev, "Error initializing I2C regmap\n");
+		return PTR_ERR(priv->regmap);
+	}
+
+	if (client->dev.of_node)
+		priv->pdata = adsd3500_parse_dt(client, common_data);
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops = &adsd3500_common_ops;
+	common_data->ctrl_handler = &priv->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &adsd3500_frmfmt[0];
+	common_data->colorfmt = camera_common_find_datafmt(
+					  ADSD3500_DEFAULT_DATAFMT);
+	common_data->numctrls = 0;
+	common_data->numfmts = ARRAY_SIZE(adsd3500_frmfmt);
+	common_data->def_mode = ADSD3500_DEFAULT_MODE;
+	common_data->def_width = ADSD3500_DEFAULT_WIDTH;
+	common_data->def_height = ADSD3500_DEFAULT_HEIGHT;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+
+	priv->dev = &client->dev;
+	priv->i2c_client = client;
+	priv->s_data = common_data;
+	priv->sd = &common_data->subdev;
+	priv->sd->dev = &client->dev;
+	priv->s_data->dev = &client->dev;
+	mutex_init(&priv->lock);
+
+	ret = camera_common_initialize(common_data, "adi_adsd3500");
+	if (ret) {
+		dev_err(&client->dev, "Failed to initialize adsd3500.\n");
+		return ret;
+	}
+
+	priv->current_config.nr_mipi_lanes = common_data->numlanes;
+	dev_dbg(&client->dev, "Lanes nr: %u\n", priv->current_config.nr_mipi_lanes);
+
+	ret = regmap_read(priv->regmap, GET_CHIP_ID_CMD, &read_val);
+	if (ret < 0) {
+		dev_err(&client->dev, "Read of Chip ID register failed.\n");
+		return -EIO;
+	}
+#if 0
+
+	if (read_val != ADSD3500_CHIP_ID) {
+		dev_err(&client->dev, "Chip ID: %.4X is wrong.\n", read_val);
+		return -EFAULT;
+	}
+	dev_dbg(&client->dev, "Read Chip ID: %.4X\n", read_val);
+#endif
+	v4l2_i2c_subdev_init(priv->sd, client, &adsd3500_subdev_ops);
+	
+	ret = adsd3500_ctrls_init(priv);
+	if (ret)
+		return ret;
+
+	priv->sd->internal_ops = &adsd3500_subdev_internal_ops;
+	priv->sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->sd->entity.ops = &adsd3500_subdev_entity_ops;
+	ret = tegra_media_entity_init(&priv->sd->entity, 1,
+				&priv->pad, true, true);
+	if (ret) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return ret;
+	}
+
+	ret = v4l2_async_register_subdev(priv->sd);
+	if (ret) {
+		dev_err(&client->dev, "could not register v4l2 device\n");
+		return ret;
+	}
+
+	dev_info(&client->dev, "Detected ADSD3500 sensor\n");
+
+	return 0;
+}
+
+static int adsd3500_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct adsd3500 *priv = (struct adsd3500 *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->sd);
+	media_entity_cleanup(&priv->sd->entity);
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	camera_common_cleanup(priv->s_data);
+	mutex_destroy(&priv->lock);
+
+	return 0;
+}
+
+static const struct i2c_device_id adsd3500_id[] = {
+	{ "adsd3500", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, adsd3500_id);
+
+static struct i2c_driver adsd3500_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(adsd3500_of_match),
+		.name		= "adsd3500",
+	},
+	.probe			= adsd3500_probe,
+	.remove			= adsd3500_remove,
+	.id_table 		= adsd3500_id,
+};
+
+module_i2c_driver(adsd3500_i2c_driver);
+
+MODULE_DESCRIPTION("Analog Devices ADSD3500 Driver");
+MODULE_AUTHOR("Bogdan Togorean");
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/adsd3500_mode_tbls.h b/kernel/nvidia/drivers/media/i2c/adsd3500_mode_tbls.h
new file mode 100644
index 000000000000..9fe106cde1d2
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/adsd3500_mode_tbls.h
@@ -0,0 +1,40 @@
+#ifndef __ADSD3500_I2C_TABLES__
+#define __ADSD3500_I2C_TABLES__
+
+#define ADSD3500_TABLE_WAIT_MS	0
+#define ADSD3500_TABLE_END	1
+
+enum {
+	ADSD3500_MODE_512x512_30FPS,
+	ADSD3500_MODE_1024x512_30FPS,
+	ADSD3500_MODE_1280x512_30FPS,
+	ADSD3500_MODE_1536x512_30FPS,
+	ADSD3500_MODE_1792x512_30FPS,
+	ADSD3500_MODE_2048x512_30FPS,
+	ADSD3500_MODE_2304x512_30FPS,
+	ADSD3500_MODE_2560x512_30FPS,
+	ADSD3500_MODE_3072x1024_30FPS,
+};
+
+static const int adsd3500_30fps[] = {
+	30,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in
+ * device tree!
+ */
+static const struct camera_common_frmfmt adsd3500_frmfmt[] = {
+	{{512, 512},	adsd3500_30fps, 1, 0, ADSD3500_MODE_512x512_30FPS},
+	{{1024, 512},	adsd3500_30fps, 1, 0, ADSD3500_MODE_1024x512_30FPS},
+	{{1280, 512},	adsd3500_30fps, 1, 0, ADSD3500_MODE_1280x512_30FPS},
+	{{1536, 512},	adsd3500_30fps, 1, 0, ADSD3500_MODE_1536x512_30FPS},
+	{{1792, 512},	adsd3500_30fps, 1, 0, ADSD3500_MODE_1792x512_30FPS},
+	{{2048, 512},	adsd3500_30fps, 1, 0, ADSD3500_MODE_2048x512_30FPS},
+	{{2304, 512},	adsd3500_30fps, 1, 0, ADSD3500_MODE_2304x512_30FPS},
+	{{2560, 512},	adsd3500_30fps, 1, 0, ADSD3500_MODE_2560x512_30FPS},
+	{{3072, 1024},	adsd3500_30fps, 1, 0, ADSD3500_MODE_3072x1024_30FPS},
+	/* Add modes with no device tree support after below */
+};
+
+#endif /* __ADSD3500_I2C_TABLES__ */
diff --git a/kernel/nvidia/drivers/media/i2c/adsd3500_regs.h b/kernel/nvidia/drivers/media/i2c/adsd3500_regs.h
new file mode 100644
index 000000000000..e218355edaa4
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/adsd3500_regs.h
@@ -0,0 +1,64 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for the Analog Devices ADSD3500 chip.
+ *
+ * Copyright (C) 2022 Analog Devices, All Rights Reserved.
+ *
+ */
+
+#ifndef _ADI_ADSD3500_REGS_H_
+#define _ADI_ADSD3500_REGS_H_
+
+#include <linux/bitfield.h>
+
+#define GET_CHIP_ID_CMD				0x0112
+
+#define STREAM_ON_CMD				0x00AD
+#define STREAM_ON_VAL				0x00C5
+
+#define STREAM_OFF_CMD				0x000C
+#define STREAM_OFF_VAL				0x0002
+
+#define SET_IMAGER_MODE_CMD			0xDA00
+#define SET_IMAGER_MODE_MSK			GENMASK(7, 0)
+#define SET_IMAGER_MODE(x)			FIELD_PREP(SET_IMAGER_MODE_MSK, x)
+#define SET_IMAGER_MODE_DEPTH_EN_MSK		BIT_MASK(0)
+#define SET_IMAGER_MODE_DEPTH_EN(x)		FIELD_PREP(SET_IMAGER_MODE_DEPTH_EN_MSK, x)
+#define SET_IMAGER_MODE_VC_EN_MSK		BIT_MASK(1)
+#define SET_IMAGER_MODE_VC_EN(x)		FIELD_PREP(SET_IMAGER_MODE_VC_EN_MSK, x)
+#define SET_IMAGER_MODE_AB_EN_MSK		BIT_MASK(2)
+#define SET_IMAGER_MODE_AB_EN(x)		FIELD_PREP(SET_IMAGER_MODE_AB_EN_MSK, x)
+#define SET_IMAGER_MODE_AB_AVG_EN_MSK		BIT_MASK(3)
+#define SET_IMAGER_MODE_AB_AVG_EN(x)		FIELD_PREP(SET_IMAGER_MODE_AB_AVG_EN_MSK, x)
+#define SET_IMAGER_MODE_DEPTH_BITS_MSK		GENMASK(6, 4)
+#define SET_IMAGER_MODE_DEPTH_BITS(x)		FIELD_PREP(SET_IMAGER_MODE_DEPTH_BITS_MSK, x)
+#define SET_IMAGER_MODE_AB_BITS_MSK		GENMASK(9, 7)
+#define SET_IMAGER_MODE_AB_BITS(x)		FIELD_PREP(SET_IMAGER_MODE_AB_BITS_MSK, x)
+#define SET_IMAGER_MODE_CONF_BITS_MSK		GENMASK(11, 10)
+#define SET_IMAGER_MODE_CONF_BITS(x)		FIELD_PREP(SET_IMAGER_MODE_CONF_BITS_MSK, x)
+#define SET_IMAGER_MODE_MIPI_LANES_NR_MSK	GENMASK(13, 12)
+#define SET_IMAGER_MODE_MIPI_LANES_NR(x)	FIELD_PREP(SET_IMAGER_MODE_MIPI_LANES_NR_MSK, x)
+
+#define GET_IMAGER_MODE_CMD			0x0012
+#define GET_IMAGER_AB_INVLD_TRSHLD		0x0015
+#define GET_IMAGER_CONFIDENCE_TRSHLD		0x0016
+#define GET_IMAGER_JBLF_STATE			0x0017
+#define GET_IMAGER_JBLF_FILT_SIZE		0x0018
+
+#define SET_FRAMERATE_CMD			0x0022
+#define GET_FRAMERATE_CMD			0x0023
+
+#define GET_STATUS_CMD				0x0020
+
+#define READ_REGISTER_CMD			0xFFFF
+#define WRITE_REGISTER_CMD			0xFFFF
+
+#define READ_IMAGER_REGISTER_CMD(x)		(0xD000 | (0xFFF & x))
+#define WRITE_IMAGER_REGISTER_CMD(x)		(0xE000 | (0xFFF & x))
+
+#define SWITCH_TO_BURST_CMD			0x0019
+#define SWITCH_TO_STANDARD_CMD			0xFFFF
+
+#define ADSD3500_CHIP_ID			0x5931
+
+#endif /* _ADI_ADSD3500_REGS_H_ */
