<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>hspapi: shack.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">hspapi
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b70396b4a892a9c85965c69cbcd98174.html">hspapi</a></li><li class="navelem"><a class="el" href="dir_30641201d7fed37d67776e8f4780c5f7.html">inc</a></li><li class="navelem"><a class="el" href="dir_14e24802cc00ffb4b7de3e718929da8d.html">shack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">shack.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for SHACK functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;utils/generic/generic.h&quot;</code><br/>
<code>#include &quot;crypto/ccs/ccs.h&quot;</code><br/>
<code>#include &quot;crypto/ksu/ksu.h&quot;</code><br/>
<code>#include &quot;crypto/pka/pka.h&quot;</code><br/>
</div>
<p><a href="shack_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aef9f4b026f0d0193bccf8833576c3980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#aef9f4b026f0d0193bccf8833576c3980">ShackSetKey</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target, ConstPtr_Msg256_t keyData, uint32_t attributes)</td></tr>
<tr class="memdesc:aef9f4b026f0d0193bccf8833576c3980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a key value into a key slot along with supplied attributes.  <a href="#aef9f4b026f0d0193bccf8833576c3980">More...</a><br/></td></tr>
<tr class="separator:aef9f4b026f0d0193bccf8833576c3980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab400a957671d82d610d1c7c8ab8ca382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#ab400a957671d82d610d1c7c8ab8ca382">ShackClearKey</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target)</td></tr>
<tr class="memdesc:ab400a957671d82d610d1c7c8ab8ca382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the data in a key slot.  <a href="#ab400a957671d82d610d1c7c8ab8ca382">More...</a><br/></td></tr>
<tr class="separator:ab400a957671d82d610d1c7c8ab8ca382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada18c01556036158f41f71366227fd6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#ada18c01556036158f41f71366227fd6e">ShackGenRandomKey</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target, uint32_t attributes)</td></tr>
<tr class="memdesc:ada18c01556036158f41f71366227fd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random key and place it in a key slot along with supplied attributes.  <a href="#ada18c01556036158f41f71366227fd6e">More...</a><br/></td></tr>
<tr class="separator:ada18c01556036158f41f71366227fd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4f36e7dd353e4d9b4a59edc8531df0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a1f4f36e7dd353e4d9b4a59edc8531df0">ShackSendKey</a> (void *target, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> source)</td></tr>
<tr class="memdesc:a1f4f36e7dd353e4d9b4a59edc8531df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a key through a private hardware channel to another silicon based crypto accelerator on the same die.  <a href="#a1f4f36e7dd353e4d9b4a59edc8531df0">More...</a><br/></td></tr>
<tr class="separator:a1f4f36e7dd353e4d9b4a59edc8531df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73a3c9113131e22421db1074cdad8ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#ad73a3c9113131e22421db1074cdad8ee">ShackLoadKey</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> decryptor, ConstPtr_Msg384_t keyBlob)</td></tr>
<tr class="memdesc:ad73a3c9113131e22421db1074cdad8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a key into a key slot.  <a href="#ad73a3c9113131e22421db1074cdad8ee">More...</a><br/></td></tr>
<tr class="separator:ad73a3c9113131e22421db1074cdad8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30622da3a6be645e2e5dcbef35fe1730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a30622da3a6be645e2e5dcbef35fe1730">DecryptLegacyKey</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> decryptor, ConstPtr_Msg384_t keyBlob, uint32_t attributes)</td></tr>
<tr class="memdesc:a30622da3a6be645e2e5dcbef35fe1730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypts and loads a legacy key into a key slot.  <a href="#a30622da3a6be645e2e5dcbef35fe1730">More...</a><br/></td></tr>
<tr class="separator:a30622da3a6be645e2e5dcbef35fe1730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef864a8f5992d8626df2b5f6ac03fe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a4ef864a8f5992d8626df2b5f6ac03fe7">ShackStoreKey</a> (ConstPtr_Msg256_t keyData, uint32_t attributes, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> encryptor, Ptr_Msg384_t keyBlob)</td></tr>
<tr class="memdesc:a4ef864a8f5992d8626df2b5f6ac03fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a key into a key blob.  <a href="#a4ef864a8f5992d8626df2b5f6ac03fe7">More...</a><br/></td></tr>
<tr class="separator:a4ef864a8f5992d8626df2b5f6ac03fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdddf2b7c66040b9f1cd5583c25d3c88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#afdddf2b7c66040b9f1cd5583c25d3c88">ShackSaveKey</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> source, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> encryptor, Ptr_Msg384_t keyBlob)</td></tr>
<tr class="memdesc:afdddf2b7c66040b9f1cd5583c25d3c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a key into a key blob.  <a href="#afdddf2b7c66040b9f1cd5583c25d3c88">More...</a><br/></td></tr>
<tr class="separator:afdddf2b7c66040b9f1cd5583c25d3c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed21aacc244eedc3fe8617e90e9e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a98ed21aacc244eedc3fe8617e90e9e46">ShackKdfKey</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> source, ConstPtr_Msg256_t data, uint32_t attributes)</td></tr>
<tr class="memdesc:a98ed21aacc244eedc3fe8617e90e9e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply KDF function to source key, attributes, and 256-bit input to derive a new key.  <a href="#a98ed21aacc244eedc3fe8617e90e9e46">More...</a><br/></td></tr>
<tr class="separator:a98ed21aacc244eedc3fe8617e90e9e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a8c94f99eb6a7dbc2363e96db26f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a13a8c94f99eb6a7dbc2363e96db26f3a">ShackKdfKeyEx</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> source, const void *data, uint32_t size, uint32_t attributes)</td></tr>
<tr class="memdesc:a13a8c94f99eb6a7dbc2363e96db26f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply KDF function to source key, attributes, and arbitrarily sized input to derive a new key.  <a href="#a13a8c94f99eb6a7dbc2363e96db26f3a">More...</a><br/></td></tr>
<tr class="separator:a13a8c94f99eb6a7dbc2363e96db26f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063c92006030df04edc285e05867df27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a063c92006030df04edc285e05867df27">ShackKdfPcr</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> source, <a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a> pcrSlot, uint32_t attributes)</td></tr>
<tr class="memdesc:a063c92006030df04edc285e05867df27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply KDF function to source key, PCR value, and attributes to derive a new key.  <a href="#a063c92006030df04edc285e05867df27">More...</a><br/></td></tr>
<tr class="separator:a063c92006030df04edc285e05867df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af854a29c11157d9452b7a44932ebd6da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#af854a29c11157d9452b7a44932ebd6da">ShackKdfAsPcr</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> source, <a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a> pcrSlot, uint32_t attributes)</td></tr>
<tr class="memdesc:af854a29c11157d9452b7a44932ebd6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply KDF function to source key, target PCR value, and attributes to derive a new key.  <a href="#af854a29c11157d9452b7a44932ebd6da">More...</a><br/></td></tr>
<tr class="separator:af854a29c11157d9452b7a44932ebd6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1507d3170a6f2b4b531cc1ea486e66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a2d1507d3170a6f2b4b531cc1ea486e66">ShackDeriveEccPublicKey</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> source, Ptr_Msg512_t publicKey)</td></tr>
<tr class="memdesc:a2d1507d3170a6f2b4b531cc1ea486e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the ECC public key using the specified ECC Private key.  <a href="#a2d1507d3170a6f2b4b531cc1ea486e66">More...</a><br/></td></tr>
<tr class="separator:a2d1507d3170a6f2b4b531cc1ea486e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b76229e542ee510ba667632a8cdd10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a60b76229e542ee510ba667632a8cdd10">ShackEccPcrSign</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> source, <a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a> pcrReg, ConstPtr_Msg256_t data, Ptr_Msg512_t signature)</td></tr>
<tr class="memdesc:a60b76229e542ee510ba667632a8cdd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the specified signing ECC private key to sign the hash of the concatenation of the specified PCR value and the 256-bit input.  <a href="#a60b76229e542ee510ba667632a8cdd10">More...</a><br/></td></tr>
<tr class="separator:a60b76229e542ee510ba667632a8cdd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada3591edf5f4d603e5d931376a4d2fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#aada3591edf5f4d603e5d931376a4d2fc">ShackEccSign</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> source, ConstPtr_Msg256_t data, Ptr_Msg512_t signature)</td></tr>
<tr class="memdesc:aada3591edf5f4d603e5d931376a4d2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the specified signing ECC private key to sign the 256-bit input value.  <a href="#aada3591edf5f4d603e5d931376a4d2fc">More...</a><br/></td></tr>
<tr class="separator:aada3591edf5f4d603e5d931376a4d2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29f2d3ba80e674692e443c96ca70226"><td class="memItemLeft" align="right" valign="top">Hsp_Status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#af29f2d3ba80e674692e443c96ca70226">ShackEccVerifySignature</a> (ConstPtr_Msg512_t publicKey, ConstPtr_Msg256_t digest, ConstPtr_Msg512_t signature)</td></tr>
<tr class="memdesc:af29f2d3ba80e674692e443c96ca70226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the provided ECC public key to verify a given message digest against a given signature.  <a href="#af29f2d3ba80e674692e443c96ca70226">More...</a><br/></td></tr>
<tr class="separator:af29f2d3ba80e674692e443c96ca70226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60536cc095e769d7fb7d8c1e8b8f4885"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a60536cc095e769d7fb7d8c1e8b8f4885">ShackEcdhPcrKeyExchange</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> eccKey, <a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a> pcrReg, ConstPtr_Msg512_t publicKey, uint32_t attributes)</td></tr>
<tr class="memdesc:a60536cc095e769d7fb7d8c1e8b8f4885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the specified ECC private key to perform ECDH with the supplied public key.  <a href="#a60536cc095e769d7fb7d8c1e8b8f4885">More...</a><br/></td></tr>
<tr class="separator:a60536cc095e769d7fb7d8c1e8b8f4885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b08cdbd3de0bac9f3f23e04e548e24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#ab8b08cdbd3de0bac9f3f23e04e548e24">ShackEcdhKeyExchange</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> target, <a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> eccKey, ConstPtr_Msg512_t publicKey, uint32_t attributes)</td></tr>
<tr class="memdesc:ab8b08cdbd3de0bac9f3f23e04e548e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the specified ECC private key to perform ECDH with the supplied public key.  <a href="#ab8b08cdbd3de0bac9f3f23e04e548e24">More...</a><br/></td></tr>
<tr class="separator:ab8b08cdbd3de0bac9f3f23e04e548e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3044e07884d60ac7f3e57efdf6b97767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a3044e07884d60ac7f3e57efdf6b97767">ShackExtendPcr</a> (<a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a> target, ConstPtr_Msg256_t data)</td></tr>
<tr class="memdesc:a3044e07884d60ac7f3e57efdf6b97767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend a value into a PCR register.  <a href="#a3044e07884d60ac7f3e57efdf6b97767">More...</a><br/></td></tr>
<tr class="separator:a3044e07884d60ac7f3e57efdf6b97767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc99b6dbc39cc41f34cf8faa0eaa165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a9bc99b6dbc39cc41f34cf8faa0eaa165">ShackExtendPcrEx</a> (<a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a> target, const void *data, uint32_t size)</td></tr>
<tr class="memdesc:a9bc99b6dbc39cc41f34cf8faa0eaa165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend an arbitrarily sized value into a PCR register.  <a href="#a9bc99b6dbc39cc41f34cf8faa0eaa165">More...</a><br/></td></tr>
<tr class="separator:a9bc99b6dbc39cc41f34cf8faa0eaa165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff97ebdffe5f11f7ff58185dd5a6fe72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#aff97ebdffe5f11f7ff58185dd5a6fe72">ShackBurnKey</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> keySlot)</td></tr>
<tr class="memdesc:aff97ebdffe5f11f7ff58185dd5a6fe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Burn the key and attributes in a key slot into the corresponding fuse location.  <a href="#aff97ebdffe5f11f7ff58185dd5a6fe72">More...</a><br/></td></tr>
<tr class="separator:aff97ebdffe5f11f7ff58185dd5a6fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17180c848104d74024a7afaff1cae44c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a17180c848104d74024a7afaff1cae44c">ShackAesCbc256Decrypt</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> key, ConstPtr_Msg128_t initialVec, void *dataIn, uint32_t dataLen, void *dataOut, bool waitCompletion)</td></tr>
<tr class="memdesc:a17180c848104d74024a7afaff1cae44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt payload using CBC mode.  <a href="#a17180c848104d74024a7afaff1cae44c">More...</a><br/></td></tr>
<tr class="separator:a17180c848104d74024a7afaff1cae44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f639d622b01364f4d212f329281dd73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shack_8h.html#a3f639d622b01364f4d212f329281dd73">ShackAesCbc256Encrypt</a> (<a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a> key, ConstPtr_Msg128_t initialVec, void *dataIn, uint32_t dataLen, void *dataOut, bool waitCompletion)</td></tr>
<tr class="memdesc:a3f639d622b01364f4d212f329281dd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt payload using CBC mode.  <a href="#a3f639d622b01364f4d212f329281dd73">More...</a><br/></td></tr>
<tr class="separator:a3f639d622b01364f4d212f329281dd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for SHACK functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a30622da3a6be645e2e5dcbef35fe1730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DecryptLegacyKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>decryptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg384_t&#160;</td>
          <td class="paramname"><em>keyBlob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypts and loads a legacy key into a key slot. </p>
<p><b>Description:</b> This operation mimics the KR_D_Decrypt operation on HSP 1.0 and is needed to support legacy applications. It takes an AES encrypted 256-bit key blob, decrypts it using the specified key register and loads the resulting key and into a key register. The attributes on the destination key will default to zeros except the following five attributes that will be copied from the input attribute parameter: SendKeyAllowed, AESEncryptAllowed, AESDecryptAllowed, AES128bitAllowed, and AESXTSOnly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
    <tr><td class="paramname">decryptor</td><td>Decryption key slot</td></tr>
    <tr><td class="paramname">keyBlob</td><td>Legacy key blob address</td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a17180c848104d74024a7afaff1cae44c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackAesCbc256Decrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg128_t&#160;</td>
          <td class="paramname"><em>initialVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitCompletion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt payload using CBC mode. </p>
<p><b>Description:</b> Decrypt payload with provided with key and initial vector under AES CBC mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>256 bit AES CBC key slot id.</td></tr>
    <tr><td class="paramname">initialVec</td><td>128 bit initial input vector. In case of chaining multiple AES operations, initialVec needs to be provided in first call to the API, later calls it has to be null.</td></tr>
    <tr><td class="paramname">dataIn</td><td>pointer to where input data is stored, has to be in sharedram</td></tr>
    <tr><td class="paramname">dataLen</td><td>size of data in bytes</td></tr>
    <tr><td class="paramname">dataOut</td><td>pointer to where decrypted data will be stored, has to be in sharedram</td></tr>
    <tr><td class="paramname">waitCompletion</td><td>wait on completion or defered check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a3f639d622b01364f4d212f329281dd73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackAesCbc256Encrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg128_t&#160;</td>
          <td class="paramname"><em>initialVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitCompletion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt payload using CBC mode. </p>
<p><b>Description:</b> Encrypt payload with provided with key and initial vector under AES CBC mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>256 bit AES CBC key slot id.</td></tr>
    <tr><td class="paramname">initialVec</td><td>128 bit initial input vector. In case of chaining multiple AES operations, initialVec needs to be provided in first call to the API, later calls it has to be null.</td></tr>
    <tr><td class="paramname">dataIn</td><td>pointer to where input data is stored, has to be in sharedram</td></tr>
    <tr><td class="paramname">dataLen</td><td>size of data in bytes</td></tr>
    <tr><td class="paramname">dataOut</td><td>pointer to where encrypted data will be stored, has to be in sharedram</td></tr>
    <tr><td class="paramname">waitCompletion</td><td>wait on completion or defered check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aff97ebdffe5f11f7ff58185dd5a6fe72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackBurnKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>keySlot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Burn the key and attributes in a key slot into the corresponding fuse location. </p>
<p><b>Description:</b> Copy the key and attributes in the specified key slot to the fuse location corresponding to this key slot. This command first makes sure all fuses associated with the specified key slot are unprogrammed and then programs the key value and attributes in fuses using fuse controller commands. Only the first N (currently N=4) key slots have corresponding fuses. The fuse controller sends these values to KSU through the KSU import interface at initialization. If an improper key slot is specified, the command will fail with no changes to keys, or fuses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keySlot</td><td>Key slot</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ab400a957671d82d610d1c7c8ab8ca382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackClearKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the data in a key slot. </p>
<p><b>Description:</b> Clears the data in a key slot by setting it to all zero, including attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a2d1507d3170a6f2b4b531cc1ea486e66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackDeriveEccPublicKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr_Msg512_t&#160;</td>
          <td class="paramname"><em>publicKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the ECC public key using the specified ECC Private key. </p>
<p><b>Description:</b> Apply the appropriate ECC operation on the ECC Private key in the specified key slot to generate the corresponding ECC public key and return the ECC public key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source key slot</td></tr>
    <tr><td class="paramname">publicKey</td><td>Address to receive 512-bit output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a60b76229e542ee510ba667632a8cdd10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackEccPcrSign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a>&#160;</td>
          <td class="paramname"><em>pcrReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg256_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr_Msg512_t&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the specified signing ECC private key to sign the hash of the concatenation of the specified PCR value and the 256-bit input. </p>
<p><b>Description:</b> Use the specified signing ECC private key to sign the SHA256_AUTOPAD hash of the concatenation of the specified PCR value, and the 256-bit input. The operations are: Temp = SHA256_AUTOPAD(input value || PCR value) ECDSA signature = ECC256_sign(Temp, ECC Signing key)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source key slot</td></tr>
    <tr><td class="paramname">pcrReg</td><td>PCR slot</td></tr>
    <tr><td class="paramname">data</td><td>Address of 256-bit input</td></tr>
    <tr><td class="paramname">signature</td><td>Output signature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aada3591edf5f4d603e5d931376a4d2fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackEccSign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg256_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr_Msg512_t&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the specified signing ECC private key to sign the 256-bit input value. </p>
<p><b>Description:</b> Use the specified signing ECC private key to sign the 256-bit input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source key slot</td></tr>
    <tr><td class="paramname">data</td><td>Address of 256-bit input</td></tr>
    <tr><td class="paramname">signature</td><td>Output signature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="af29f2d3ba80e674692e443c96ca70226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Hsp_Status_t ShackEccVerifySignature </td>
          <td>(</td>
          <td class="paramtype">ConstPtr_Msg512_t&#160;</td>
          <td class="paramname"><em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg256_t&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg512_t&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the provided ECC public key to verify a given message digest against a given signature. </p>
<p><b>Description:</b> Use the provided 512-bit ECC public key to verify a given message digest (256-bit hash) against a given 512-bit signature. <code>HSP_SUCCESS</code> is returned if verification succeeds, or <code>HSP_SIGNATURE_MISMATCH</code> if it fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">publicKey</td><td>Address of 512-bit ECC public key. Will be copied into shared memory (i.e. HSP accessible) if necessary.</td></tr>
    <tr><td class="paramname">digest</td><td>Address of 256-bit SHA digest. Must be HSP accessible (i.e. in shared memory).</td></tr>
    <tr><td class="paramname">signature</td><td>Address of 512-bit signature. Must be HSP accessible (i.e. in shared memory).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>HSP_SUCCESS</code> if successful, or <code>HSP_SIGNATURE_MISMATCH</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8b08cdbd3de0bac9f3f23e04e548e24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackEcdhKeyExchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>eccKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg512_t&#160;</td>
          <td class="paramname"><em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the specified ECC private key to perform ECDH with the supplied public key. </p>
<p><b>Description:</b> Use the specified ECC private key to perform ECDH with the provided public key. The resulting EC point’s X coordinate is hashed with the Destination Attributes to form the 256-bit key placed in the destination key slot. The Destination Attributes are placed in the destination key slot. The operations are: Shared secret = ECC_PT_MULTIPLICATION_256(ECC private key, partner public key) Destination key = SHA256_AUTOPAD(Shared secret X coordinate || Destination attributes)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
    <tr><td class="paramname">eccKey</td><td>Private ECC key slot</td></tr>
    <tr><td class="paramname">publicKey</td><td>Address of partner public key</td></tr>
    <tr><td class="paramname">attributes</td><td>Destination attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a60536cc095e769d7fb7d8c1e8b8f4885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackEcdhPcrKeyExchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>eccKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a>&#160;</td>
          <td class="paramname"><em>pcrReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg512_t&#160;</td>
          <td class="paramname"><em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the specified ECC private key to perform ECDH with the supplied public key. </p>
<p><b>Description:</b> Use the specified ECC private key to perform ECDH with the supplied public key. The resulting EC point’s X coordinate is hashed with the Destination Attributes and the PCR value in the supplied PCR slot number to form the 256-bit key which is placed into the destination key slot. The Destination Attributes are placed in the destination key slot. The operations are: Shared secret = ECC_PT_MULTIPLICATION_256(Private ECC key, partner public key) Destination key = SHA256_AUTOPAD(Shared secret X coordinate || PCR value || Destination attributes)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
    <tr><td class="paramname">eccKey</td><td>Private ECC key slot</td></tr>
    <tr><td class="paramname">pcrReg</td><td>PCR slot</td></tr>
    <tr><td class="paramname">publicKey</td><td>Address of partner public key</td></tr>
    <tr><td class="paramname">attributes</td><td>Destination attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a3044e07884d60ac7f3e57efdf6b97767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackExtendPcr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg256_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend a value into a PCR register. </p>
<p><b>Description:</b> Extend a value into a PCR register. The new PCR value is the SHA-256 of the concatenation of the PCR value with the input 256-bit value added to the end of the SHA message. New PCR value = SHA256_AUTOPAD(PCR_value || 256-bit input value).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>PCR slot</td></tr>
    <tr><td class="paramname">data</td><td>Address of 256-bit input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a9bc99b6dbc39cc41f34cf8faa0eaa165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackExtendPcrEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend an arbitrarily sized value into a PCR register. </p>
<p><b>Description:</b> Extend a value into a PCR register. Similar to <code>ShackExtendPcr</code> but takes any sized buffer (up to 256 bits).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>PCR slot</td></tr>
    <tr><td class="paramname">data</td><td>Address of input data</td></tr>
    <tr><td class="paramname">size</td><td>Size of input data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ada18c01556036158f41f71366227fd6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackGenRandomKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random key and place it in a key slot along with supplied attributes. </p>
<p><b>Description:</b> Generate a random key and place it in a key slot along with supplied attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="af854a29c11157d9452b7a44932ebd6da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackKdfAsPcr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a>&#160;</td>
          <td class="paramname"><em>pcrSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply KDF function to source key, target PCR value, and attributes to derive a new key. </p>
<p><b>Description:</b> A SHA-256 based KDF function (must match one used by KDFPCR) is applied to the source key, the supplied target PCR value, and the supplied attributes to derive a new key. The target PCR is expected value of a PCR register that would allow deriving this key in the future using a KDFPCR command. The new key along with the attributes is stored in the destination key slot. However, the attributes in the destination key slot are modified by clearing the LoadKeyAllowed attribute and setting the StoreKeyAllowed attribute. This enables the destination key slot to be used for storing keys that can be loaded in the future when the exact same key is generated into a key slot using KDFPCR. After the command completes, key in the destination address = SHA256_AUTOPAD(source key || Target PCR || new attributes). This complex command is different from all others in that the attributes used in the KDF function are not the same as the ones written out at the destination key slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
    <tr><td class="paramname">source</td><td>Source key slot</td></tr>
    <tr><td class="paramname">pcrSlot</td><td>Target PCR value</td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a98ed21aacc244eedc3fe8617e90e9e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackKdfKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg256_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply KDF function to source key, attributes, and 256-bit input to derive a new key. </p>
<p><b>Description:</b> A SHA-256 based KDF function is applied to the key in the source key slot, the supplied attributes, and the 256-bit input to derive a new key. The new key along with the new attributes are stored in the destination key slot. If the ECCSignAllowed or ECDHAllowed attribute bit is set in the input attribute field, the resulting key from the KDFKey operation must conform to the requirements of a private ECC-P256 key (automatically satisfied by MS PKA engine). After the command completes, key in destination address = SHA256_AUTOPAD(input bits || source key || new attributes). “new attributes” means 24-bits of attributes for the newly derived key after enforcement of all attribute requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
    <tr><td class="paramname">source</td><td>Source key slot</td></tr>
    <tr><td class="paramname">data</td><td>Address of 256-bit input</td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a13a8c94f99eb6a7dbc2363e96db26f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackKdfKeyEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply KDF function to source key, attributes, and arbitrarily sized input to derive a new key. </p>
<p><b>Description:</b> KDF a key with a value. Similar to <code>ShackExtendPcr</code> but takes any sized buffer (up to 256 bits).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
    <tr><td class="paramname">source</td><td>Source key slot</td></tr>
    <tr><td class="paramname">data</td><td>Address of input data</td></tr>
    <tr><td class="paramname">size</td><td>Size of input data</td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a063c92006030df04edc285e05867df27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackKdfPcr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#aeca73a12006d9b38eb209cc0f7cd31ef">Ksu_Pcr_Slot_t</a>&#160;</td>
          <td class="paramname"><em>pcrSlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply KDF function to source key, PCR value, and attributes to derive a new key. </p>
<p><b>Description:</b> A SHA-256 based KDF function is applied to the source key, and the PCR value, and the supplied attributes to derive a new key. The order of arguments for the SHA-256 is intentionally different from the KDFKey command. The new key along with the new attributes is stored in the destination key slot. Note: If the ECDSAAllowed or ECDHAllowed attribute bit is set in the input attribute field, the resulting key from the KDFPCR operation must conform to the requirements of a private ECC-P256 key (automatically satisfied by MS PKA engine). After the command completes, the key in destination address = SHA256_AUTOPAD(source key || PCR || new attributes). The “new attributes” argument means 24-bits of attributes for the newly-derived key after enforcement of all attribute requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
    <tr><td class="paramname">source</td><td>Source key slot</td></tr>
    <tr><td class="paramname">pcrSlot</td><td>PCR slot</td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ad73a3c9113131e22421db1074cdad8ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackLoadKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>decryptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg384_t&#160;</td>
          <td class="paramname"><em>keyBlob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a key into a key slot. </p>
<p><b>Description:</b> Takes a key blob which contains a 256-bit key, associated attributes, and 64-bit Initial Value (IV) value; decrypts and verifies the IV value. If the integrity check passes, the decrypted key and its attributes are loaded into the destination key slot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
    <tr><td class="paramname">decryptor</td><td>Decryption key slot</td></tr>
    <tr><td class="paramname">keyBlob</td><td>Key blob address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="afdddf2b7c66040b9f1cd5583c25d3c88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackSaveKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>encryptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr_Msg384_t&#160;</td>
          <td class="paramname"><em>keyBlob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a key into a key blob. </p>
<p><b>Description:</b> Takes a key slot to save and uses the key value in the encryption key slot to encrypt and integrity tag the saved key value and attributes into a key blob that can be used by LoadKey in the future. The future LoadKey will only succeed if the key in the source key slot is the same as the value in the source key at SaveKey time. Note that this SaveKey operation will only be performed if the encryption key slot has the IsDeviceSecret attribute set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source key slot</td></tr>
    <tr><td class="paramname">encryptor</td><td>Encryption key slot</td></tr>
    <tr><td class="paramname">keyBlob</td><td>Output key blob address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a1f4f36e7dd353e4d9b4a59edc8531df0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackSendKey </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a key through a private hardware channel to another silicon based crypto accelerator on the same die. </p>
<p><b>Description:</b> Sends a key through a private hardware channel to another silicon based crypto accelerator on the same die (e.g. SCP). Both the 256-bit key, and the 24 bits of attribute are sent over the private key interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key address</td></tr>
    <tr><td class="paramname">source</td><td>Source key slot</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aef9f4b026f0d0193bccf8833576c3980"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackSetKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPtr_Msg256_t&#160;</td>
          <td class="paramname"><em>keyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a key value into a key slot along with supplied attributes. </p>
<p><b>Description:</b> Set a key value into a key slot along with supplied attributes. The CCS expects IsDeviceSecret to be zero on input attributes, if it is not, it will silently clear it to zero before attributes are written to the KSU. (Note that a nonzero input value for the IsDeviceSecret attribute is not an error.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Destination key slot</td></tr>
    <tr><td class="paramname">keyData</td><td>Address of 256-bit key</td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a4ef864a8f5992d8626df2b5f6ac03fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShackStoreKey </td>
          <td>(</td>
          <td class="paramtype">ConstPtr_Msg256_t&#160;</td>
          <td class="paramname"><em>keyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="key__slots_8h.html#a32d0b2015305726d8e02f20b2b9a8ab9">Ksu_Key_Slot_t</a>&#160;</td>
          <td class="paramname"><em>encryptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr_Msg384_t&#160;</td>
          <td class="paramname"><em>keyBlob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a key into a key blob. </p>
<p><b>Description:</b> Takes a 256-bit key value, and associated 24-bit attribute as input, and uses the specified encryption key slot to encrypt and add an integrity tag value to a key blob that can be used by LoadKey in the future. The future LoadKey will only succeed if the key in the decryption register is the same as the value in the encryption key register at StoreKey time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyData</td><td>Address of 256-bit key</td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes</td></tr>
    <tr><td class="paramname">encryptor</td><td>Encryption key slot</td></tr>
    <tr><td class="paramname">keyBlob</td><td>Output key blob address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
